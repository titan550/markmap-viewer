<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paste → Markmap (+ Mermaid)</title>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/theme/dracula.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/dialog/dialog.min.css"
    />

    <style>
      :root {
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        overflow: hidden;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
      }

      #mindmap {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 16px;
        background: rgba(0, 0, 0, 0.05);
        transition: opacity 0.15s ease;
        z-index: 10;
      }
      .card {
        width: min(680px, 100%);
        border: 1px solid rgba(127, 127, 127, 0.35);
        border-radius: 12px;
        padding: 18px;
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
      }
      h1 {
        margin: 0 0 10px;
        font-size: 18px;
        font-weight: 650;
      }
      p {
        margin: 0 0 10px;
        font-size: 13px;
        opacity: 0.8;
        line-height: 1.4;
      }
      textarea {
        width: 100%;
        min-height: 170px;
        resize: vertical;
        border-radius: 10px;
        border: 1px solid rgba(127, 127, 127, 0.35);
        padding: 10px 11px;
        font:
          12.5px/1.4 ui-monospace,
          SFMono-Regular,
          Menlo,
          Monaco,
          Consolas,
          "Liberation Mono",
          monospace;
        background: transparent;
        color: inherit;
        outline: none;
      }
      textarea:focus {
        border-color: rgba(74, 158, 255, 0.9);
      }

      .hidden {
        opacity: 0;
        pointer-events: none;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        margin-top: 10px;
      }
      .button-group {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }
      .hint {
        font-size: 12px;
        opacity: 0.7;
      }
      button {
        appearance: none;
        border: 1px solid rgba(127, 127, 127, 0.35);
        background: transparent;
        color: inherit;
        padding: 7px 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 12.5px;
      }
      button:hover {
        background: rgba(127, 127, 127, 0.08);
      }

      #mindmap {
        overflow: visible;
      }
      foreignObject {
        overflow: visible;
      }
      foreignObject * {
        overflow: visible;
      }

      foreignObject img.diagram-img {
        display: block;
        max-width: 100%;
        height: auto;
      }
      foreignObject img.math-img {
        display: inline-block;
        vertical-align: middle;
      }
      foreignObject img.math-img.math-block {
        display: block;
      }
      foreignObject img.math-line-img {
        display: inline-block;
        vertical-align: middle;
      }

      #toggleEditor {
        position: fixed;
        top: 16px;
        left: 16px;
        z-index: 100;
        appearance: none;
        border: 1px solid rgba(127, 127, 127, 0.35);
        background: rgba(255, 255, 255, 0.92);
        color: inherit;
        padding: 8px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 0.2s ease;
      }
      #toggleEditor:hover {
        background: rgba(255, 255, 255, 1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      }

      #editorPanel {
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        width: 400px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-right: 1px solid rgba(127, 127, 127, 0.25);
        box-shadow: 2px 0 12px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        z-index: 90;
        transition: transform 0.3s ease;
        transform: translateX(-100%);
      }
      #editorPanel.visible {
        transform: translateX(0);
      }

      .editor-header {
        padding: 16px 18px;
        border-bottom: 1px solid rgba(127, 127, 127, 0.15);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .editor-header h2 {
        margin: 0;
        font-size: 15px;
        font-weight: 600;
      }
      #closeEditor {
        appearance: none;
        border: none;
        background: transparent;
        color: inherit;
        font-size: 24px;
        line-height: 1;
        cursor: pointer;
        padding: 0;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        opacity: 0.6;
        transition: all 0.2s ease;
      }
      #closeEditor:hover {
        background: rgba(127, 127, 127, 0.12);
        opacity: 1;
      }

      #editorTextarea {
        flex: 1;
        margin: 0;
        border: none;
        border-radius: 0;
        padding: 16px 18px;
        resize: none;
        font-size: 13px;
        line-height: 1.6;
      }

      .CodeMirror-wrap {
        flex: 1;
        display: flex;
        flex-direction: column;
      }
      .CodeMirror {
        height: 100% !important;
        flex: 1 !important;
        font-size: 13px !important;
        line-height: 1.6 !important;
        background: transparent !important;
        color: inherit !important;
      }
      .CodeMirror-gutters {
        background: transparent !important;
        border-right: 1px solid rgba(127, 127, 127, 0.1) !important;
      }
      .CodeMirror-linenumber {
        color: rgba(127, 127, 127, 0.5) !important;
      }
      .CodeMirror .cm-header {
        color: #0066cc !important;
        font-weight: 600 !important;
      }
      .CodeMirror .cm-strong {
        color: #008000 !important;
        font-weight: bold !important;
      }
      .CodeMirror .cm-em {
        color: #008000 !important;
        font-style: italic !important;
      }
      .CodeMirror .cm-link {
        color: #0066cc !important;
      }
      .CodeMirror .cm-url {
        color: #0066cc !important;
      }
      .CodeMirror .cm-quote {
        color: #666 !important;
        font-style: italic !important;
      }
      .CodeMirror .cm-comment {
        color: #666 !important;
      }
      .CodeMirror .cm-variable-2 {
        color: #d73a49 !important;
      }
      .CodeMirror .cm-variable-3 {
        color: #6f42c1 !important;
      }
      .CodeMirror-cursor {
        border-left-color: #333 !important;
      }
      .CodeMirror-dialog {
        z-index: 30;
        background: rgba(255, 255, 255, 0.9);
      }

      .editor-footer {
        padding: 10px 18px;
        border-top: 1px solid rgba(127, 127, 127, 0.15);
        font-size: 11px;
        opacity: 0.6;
      }

      #resizeHandle {
        position: fixed;
        left: 400px;
        top: 0;
        width: 6px;
        height: 100vh;
        cursor: col-resize;
        z-index: 95;
        transition: all 0.3s ease;
        transform: translateX(-100%);
        opacity: 0;
      }
      #resizeHandle.visible {
        transform: translateX(0);
        opacity: 1;
      }
      #resizeHandle:hover,
      #resizeHandle.dragging {
        background: rgba(74, 158, 255, 0.3);
      }

      #mindmap {
        transition:
          width 0.3s ease,
          margin-left 0.3s ease;
        touch-action: none;
      }
      body.editor-open #mindmap {
        width: calc(100vw - 400px);
        margin-left: 400px;
      }
    </style>
  </head>

  <body>
    <button id="toggleEditor" type="button" aria-label="Toggle Editor">Edit</button>

    <div id="editorPanel">
      <div class="editor-header">
        <h2>Markdown Editor</h2>
        <button id="closeEditor" type="button" aria-label="Close Editor">×</button>
      </div>
      <textarea
        id="editorTextarea"
        placeholder="# Your Markdown Here
## Add headings, lists, and Mermaid diagrams
```mermaid
flowchart TB
  A[Start] --> B[End]
```"
      ></textarea>
      <div class="editor-footer">
        <span id="charCount">0 characters</span>
      </div>
    </div>

    <div id="resizeHandle"></div>

    <div id="overlay" class="overlay">
      <div class="card">
        <h1>Paste Markdown → Mindmap (+ Mermaid)</h1>
        <p>Pre-render Mermaid → Markmap render → fit.</p>
        <textarea
          id="paste"
          placeholder='# Title
## Node with Mermaid
```mermaid
flowchart TB
  A["Long label that should wrap and not spill out to the right in the Mermaid node"] --> B[Done]
```'
        ></textarea>
        <div class="row">
          <div class="hint">Copy Markmap-formatted text here.</div>
          <div class="button-group">
            <button id="copyPrompt" type="button">Copy Prompt</button>
            <button id="example" type="button">Example</button>
          </div>
        </div>
      </div>
    </div>

    <svg id="mindmap"></svg>

    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/mode/overlay.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/dialog/dialog.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/search/searchcursor.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/search/search.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/markdown/markdown.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/gfm/gfm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script>
      window.MathJax = {
        startup: { typeset: false },
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
        },
        svg: { fontCache: "none" },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.18.12"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/turndown@7.2.0/dist/turndown.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@viz-js/viz@3.24.0/dist/viz-global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.1.0/skins/default.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wavedrom/3.1.0/wavedrom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-lite@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/vega-embed@7"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/json5/2.2.3/index.min.js"></script>

    <script>
      (() => {
        const $ = (s) => document.querySelector(s);

        const svgEl = $("#mindmap");
        const overlayEl = $("#overlay");
        const pasteEl = $("#paste");
        const copyPromptBtn = $("#copyPrompt");
        const exampleBtn = $("#example");

        const toggleEditorBtn = $("#toggleEditor");
        const editorPanel = $("#editorPanel");
        const closeEditorBtn = $("#closeEditor");
        const editorTextarea = $("#editorTextarea");
        const resizeHandle = $("#resizeHandle");
        const charCount = $("#charCount");

        let editorVisible = localStorage.getItem("editorVisible") === "true" || false;
        let editorWidth = parseInt(localStorage.getItem("editorWidth") || "400");
        let isResizing = false;
        let codeMirror = null;
        let codeMirrorInitialized = false;
        let pendingEditorFocus = false;

        const mmapi = window.markmap;
        if (!mmapi?.Transformer || !mmapi?.Markmap) {
          alert("Markmap failed to load.");
          return;
        }
        if (!window.TurndownService) {
          alert("Turndown failed to load.");
          return;
        }
        if (!window.mermaid?.render) {
          alert("Mermaid failed to load.");
          return;
        }

        const { Transformer, Markmap, Toolbar } = mmapi;
        const transformer = new Transformer();

        function sanitizeMermaidLabel(raw, opts = {}) {
          const {
            lineBreak = "<br/>",
            preserveExisting = true,
            normalizeHtmlEntities = true,
            useNamedColon = true,
            useMarkdownStrings = false,
          } = opts;

          if (raw == null) return "";

          let s = String(raw);
          if (useMarkdownStrings) {
            s = s.replace(/\\n/g, "\n");
            s = s.replace(/<br\s*\/?>/gi, "\n");
          }
          s = s.replace(/\r\n?/g, "\n");

          const decodeNamedEntity = (name) => {
            const map = {
              quot: '"',
              amp: "&",
              lt: "<",
              gt: ">",
              apos: "'",
              nbsp: " ",
              colon: ":",
            };
            return map[name] || null;
          };

          const decodeNumericEntity = (num) => {
            const n = Number(num);
            if (!Number.isFinite(n) || n <= 0) return null;
            try {
              return String.fromCodePoint(n);
            } catch {
              return null;
            }
          };

          const decodeHexEntity = (hex) => {
            const n = parseInt(hex, 16);
            if (!Number.isFinite(n) || n <= 0) return null;
            try {
              return String.fromCodePoint(n);
            } catch {
              return null;
            }
          };

          if (useMarkdownStrings) {
            s = s.replace(/#(\d{1,7});/g, (_, num) => decodeNumericEntity(num) ?? `#${num};`);
            s = s.replace(
              /#([A-Za-z][A-Za-z0-9]{1,31});/g,
              (_, name) => decodeNamedEntity(name) ?? `#${name};`
            );
            s = s.replace(/&#(\d+);/g, (_, num) => decodeNumericEntity(num) ?? `&#${num};`);
            s = s.replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => decodeHexEntity(hex) ?? `&#x${hex};`);
            s = s.replace(
              /&([A-Za-z][A-Za-z0-9]+);/g,
              (_, name) => decodeNamedEntity(name) ?? `&${name};`
            );
          } else if (normalizeHtmlEntities) {
            s = s.replace(/&#(\d+);/g, "#$1;");
            s = s.replace(/&([A-Za-z][A-Za-z0-9]+);/g, "#$1;");
          }

          let reAlnum;
          try {
            reAlnum = new RegExp("^[\\p{L}\\p{N}]$", "u");
          } catch {
            reAlnum = /^[A-Za-z0-9]$/;
          }

          const entityRe = /^#(?:\d{1,7}|[A-Za-z][A-Za-z0-9]{1,31});/;

          const markdownSafe = new Set([
            " ",
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            ".",
            ",",
            ":",
            ";",
            "/",
            "-",
            "_",
            "+",
            "?",
            "!",
            "%",
            '"',
            "'",
            "<",
            ">",
            "=",
            "&",
          ]);

          const encodeChunk = (chunk) => {
            let out = "";
            for (let i = 0; i < chunk.length; ) {
              if (preserveExisting && chunk[i] === "#") {
                const m = chunk.slice(i).match(entityRe);
                if (m) {
                  out += m[0];
                  i += m[0].length;
                  continue;
                }
              }

              const cp = chunk.codePointAt(i);
              const ch = String.fromCodePoint(cp);
              const step = ch.length;

              if (useMarkdownStrings) {
                if (ch === "`") {
                  out += `#${cp};`;
                } else if (cp < 32) {
                  out += `#${cp};`;
                } else {
                  out += ch;
                }
              } else if (useNamedColon && ch === ":") {
                out += "#colon;";
              } else if (reAlnum.test(ch)) {
                out += ch;
              } else {
                out += `#${cp};`;
              }

              i += step;
            }
            return out;
          };

          return s.split("\n").map(encodeChunk).join(lineBreak);
        }

        function sanitizeMermaidSourceLabels(mermaidSource, opts = {}) {
          const { useMarkdownStrings = true, wrapEdgeLabels = true } = opts;
          const patterns = [
            { open: '["', close: '"]' },
            { open: '("', close: '")' },
            { open: "{{", close: "}}" },
          ];

          const src = String(mermaidSource ?? "");
          const firstLine = src.split("\n").find((line) => line.trim()) || "";
          const diagramType = firstLine.trim().split(/\s+/)[0].toLowerCase();
          const isERDiagram = diagramType === "erdiagram";
          const allowEdgeLabels = wrapEdgeLabels && !isERDiagram;
          const allowUnquotedNodeLabels = diagramType === "flowchart" || diagramType === "graph";
          let out = "";
          let i = 0;

          const sanitizeWithMode = (inner) => {
            const trimmed = String(inner || "");
            const isWrappedMarkdown =
              trimmed.startsWith("`") &&
              trimmed.endsWith("`") &&
              !trimmed.slice(1, -1).includes("`");
            const core = isWrappedMarkdown ? trimmed.slice(1, -1) : trimmed;
            const useMarkdown = useMarkdownStrings && (isWrappedMarkdown || !core.includes("`"));
            const localOpts = {
              ...opts,
              useMarkdownStrings: useMarkdown,
              lineBreak: useMarkdown ? opts.lineBreak : "<br/>",
            };
            const cleaned = sanitizeMermaidLabel(core, localOpts);
            return useMarkdown ? "`" + cleaned + "`" : cleaned;
          };

          const isEdgeLabelStart = (pos) => {
            for (let j = pos - 1; j >= 0; j--) {
              const ch = src[j];
              if (ch === " " || ch === "\t") continue;
              return ch === "-" || ch === "=" || ch === "." || ch === ">";
            }
            return false;
          };

          const isLikelyNodeLabelStart = (pos) => {
            for (let j = pos - 1; j >= 0; j--) {
              const ch = src[j];
              if (ch === " " || ch === "\t") continue;
              return /[A-Za-z0-9_\]\)\}]/.test(ch);
            }
            return false;
          };

          while (i < src.length) {
            let p = null;
            for (const cand of patterns) {
              if (src.startsWith(cand.open, i)) {
                p = cand;
                break;
              }
            }

            if (p) {
              const start = i + p.open.length;
              const end = src.indexOf(p.close, start);
              if (end === -1) {
                out += src.slice(i);
                break;
              }
              const inner = src.slice(start, end);
              const wrapped = sanitizeWithMode(inner);
              out += p.open + wrapped + p.close;
              i = end + p.close.length;
              continue;
            }

            if (
              allowUnquotedNodeLabels &&
              (src[i] === "[" || src[i] === "(" || src[i] === "{") &&
              isLikelyNodeLabelStart(i)
            ) {
              const open = src[i];
              if (src[i + 1] === open) {
                out += src[i++];
                continue;
              }
              const close = open === "[" ? "]" : open === "(" ? ")" : "}";
              const start = i + 1;
              const end = src.indexOf(close, start);
              if (end === -1) {
                out += src.slice(i);
                break;
              }
              let inner = src.slice(start, end);
              if (inner.includes('"')) {
                inner = inner.replace(/\"/g, "'");
              }
              const wrapped = sanitizeWithMode(inner);
              const quotedOpen = open + '"';
              const quotedClose = '"' + close;
              out += quotedOpen + wrapped + quotedClose;
              i = end + 1;
              continue;
            }

            if (allowEdgeLabels && src[i] === "|" && isEdgeLabelStart(i)) {
              const start = i + 1;
              const end = src.indexOf("|", start);
              if (end === -1) {
                out += src.slice(i);
                break;
              }
              const inner = src.slice(start, end);
              const wrapped = sanitizeWithMode(inner);
              out += "|" + wrapped + "|";
              i = end + 1;
              continue;
            }

            out += src[i++];
          }

          return out;
        }
        const promptMd = [
          "Act as a thought and learning partner. Generate a high-density self-standing Markmap + Mermaid visualization. Think VERY HARD as if your life DEPENDED ON IT!",
          "",
          "",
          "### Formatting Constraints",
          "",
          "1. Container: Wrap entire response in quadruple backticks (````markdown [content] ````) to allow clean copy-pasting.",
          "",
          "2. Visual Elements (Optional/Context-Dependent):",
          "",
          "   - Mermaid diagram and charts",
          '       - Use Mermaid markdown-strings: A["`long label ...`"] for best wrapping.',
          "       - Use \\n for newlines inside labels",
          '       - Mermaid Hash-Entity Standard: Mermaid requires characters to be escaped using # instead of & (e.g., #34; instead of &quot;) - Example: `Status: "Processing #1" (Update Required)` -> `Status#colon;#32;#34;Processing#32;#35;1#34;#32;#40;Update#32;Required#41;`',
          "       - Put mermaid diagrams inside markdown code blocks starting with ```mermaid",
          "       - In flowcharts: prefer LR over TB and always include a START and END block",
          "",
          "   - Tables: Use for multi-variable comparisons",
          "",
          "   - Math: Use KaTex in markdown. Replace the \\sqrt{x} command with a fractional exponent (x)^{1/2}. Using sqrt is forbidden due to markmap bug.",
          "",
          "   - HTML (e.g., images) as it is supported by Markmap https://markmap.js.org/docs/markmap",
          "",
          "   - Code blocks with formatting",
          "",
          "   - Hyperlink references to other docs, video timestamps, etc.",
          "",
          "   - Embedded images with appropriate width and height control",
          "",
          "   - Use emojis and special chars for visual aid",
          "",
          "   - Include ascii art when other token efficient forms are incapable",
          "",
          "   - Embed the visual elements throughout the markdown where appropriate. Avoid skewing all visuals into a single node",
          "",
          "",
          "### Content & Style",
          "",
          "1. Tone: Concise. Sacrifice grammar for density.",
          "",
          "2. Structure: Use hierarchical headings (##, ###) to define the mindmap nodes. Don't mix headings and lists in the same hierarchy.",
          "",
          "3. Note that Markmap IGNORES paragraph text (i.e., not list, heading, mermaid, table or code block, etc)",
        ].join("\n");

        const mm = Markmap.create(svgEl);

        const toolbar = new Toolbar();
        toolbar.attach(mm);

        const shouldBlockWheel = (target) =>
          (target === svgEl || svgEl.contains(target)) &&
          !editorPanel.contains(target) &&
          !overlayEl.contains(target);

        svgEl.addEventListener(
          "wheel",
          (e) => {
            if (shouldBlockWheel(e.target)) e.preventDefault();
          },
          { passive: false }
        );
        const toolbarEl = toolbar.render();
        toolbarEl.style.position = "absolute";
        toolbarEl.style.right = "16px";
        toolbarEl.style.bottom = "16px";
        document.body.appendChild(toolbarEl);

        function setEditorWidth(width) {
          const minWidth = 250;
          const maxWidth = window.innerWidth - 200;
          editorWidth = Math.max(minWidth, Math.min(maxWidth, width));

          editorPanel.style.width = editorWidth + "px";
          resizeHandle.style.left = editorWidth + "px";

          if (editorVisible) {
            svgEl.style.width = `calc(100vw - ${editorWidth}px)`;
            svgEl.style.marginLeft = editorWidth + "px";
          }

          localStorage.setItem("editorWidth", editorWidth);
        }

        function focusEditor() {
          if (codeMirror) {
            codeMirror.refresh();
            codeMirror.focus();
          } else {
            editorTextarea.focus();
          }
        }

        function scheduleEditorFocus() {
          if (!editorVisible) return;
          setTimeout(() => focusEditor(), 360);
        }

        function toggleEditor(show) {
          editorVisible = show !== undefined ? show : !editorVisible;

          if (editorVisible) {
            editorPanel.classList.add("visible");
            resizeHandle.classList.add("visible");
            document.body.classList.add("editor-open");
            setEditorWidth(editorWidth);
            pendingEditorFocus = true;

            toggleEditorBtn.style.left = `${editorWidth + 16}px`;

            if (!codeMirrorInitialized) {
              initCodeMirror();
              if (pasteEl.value) {
                setEditorValue(pasteEl.value);
              }
            } else {
              if (pasteEl.value && !getEditorValue()) {
                setEditorValue(pasteEl.value);
              }
            }

            if (codeMirrorInitialized) {
              pendingEditorFocus = false;
              scheduleEditorFocus();
            }
          } else {
            editorPanel.classList.remove("visible");
            resizeHandle.classList.remove("visible");
            document.body.classList.remove("editor-open");
            svgEl.style.width = "100vw";
            svgEl.style.marginLeft = "0";

            toggleEditorBtn.style.left = "16px";
          }

          localStorage.setItem("editorVisible", editorVisible);

          setTimeout(() => mm.fit(), 320);
        }

        function updateCharCount() {
          const count = codeMirror ? codeMirror.getValue().length : editorTextarea.value.length;
          charCount.textContent = `${count} character${count !== 1 ? "s" : ""}`;
        }

        function getEditorValue() {
          return codeMirror ? codeMirror.getValue() : editorTextarea.value;
        }

        function setEditorValue(value) {
          if (codeMirror) {
            codeMirror.setValue(value || "");
          } else {
            editorTextarea.value = value || "";
          }
          updateCharCount();
        }

        let editorTimeout = null;
        const handleEditorInput = () => {
          updateCharCount();
          clearTimeout(editorTimeout);
          editorTimeout = setTimeout(() => {
            const value = getEditorValue();
            render(value);
            pasteEl.value = value;
          }, 50);
        };

        function initCodeMirror() {
          if (codeMirrorInitialized || !window.CodeMirror) return;

          try {
            codeMirror = CodeMirror.fromTextArea(editorTextarea, {
              mode: "gfm",
              lineNumbers: true,
              lineWrapping: true,
              theme: "default",
              placeholder: editorTextarea.placeholder,
              autofocus: false,
              tabSize: 2,
              indentUnit: 2,
              extraKeys: {
                "Ctrl-E": () => toggleEditor(),
                "Cmd-E": () => toggleEditor(),
                "Ctrl-F": "find",
                "Cmd-F": "find",
                "Ctrl-G": "findNext",
                "Cmd-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Cmd-G": "findPrev",
                Esc: () => {
                  if (editorVisible) toggleEditor(false);
                },
              },
            });

            if (codeMirror) {
              codeMirror.on("change", handleEditorInput);

              codeMirror.on("paste", async (instance, event) => {
                event.preventDefault();
                const mdText = await getPasteMarkdown(event.clipboardData);
                if (mdText) instance.replaceSelection(mdText, "around");
              });

              codeMirrorInitialized = true;
              if (editorVisible && pendingEditorFocus) {
                pendingEditorFocus = false;
                scheduleEditorFocus();
              }
            }
          } catch (e) {
            console.warn("CodeMirror initialization failed, using plain textarea:", e);
            codeMirror = null;
            codeMirrorInitialized = false;
            if (editorVisible && pendingEditorFocus) {
              pendingEditorFocus = false;
              setTimeout(() => editorTextarea.focus(), 0);
            }
          }
        }

        function fallbackCopyText(text) {
          const temp = document.createElement("textarea");
          temp.value = text;
          temp.setAttribute("readonly", "");
          temp.style.position = "absolute";
          temp.style.left = "-9999px";
          document.body.appendChild(temp);
          temp.select();
          try {
            document.execCommand("copy");
          } catch {}
          document.body.removeChild(temp);
        }

        async function copyPromptToClipboard() {
          try {
            await navigator.clipboard.writeText(promptMd);
            return true;
          } catch {
            fallbackCopyText(promptMd);
            return false;
          }
        }

        copyPromptBtn.addEventListener("click", async () => {
          const original = copyPromptBtn.textContent;
          const ok = await copyPromptToClipboard();
          copyPromptBtn.textContent = ok ? "Copied" : "Copied (fallback)";
          setTimeout(() => {
            copyPromptBtn.textContent = original;
          }, 1200);
        });

        toggleEditorBtn.addEventListener("click", () => toggleEditor());
        closeEditorBtn.addEventListener("click", () => toggleEditor(false));

        resizeHandle.addEventListener("mousedown", (e) => {
          isResizing = true;
          resizeHandle.classList.add("dragging");
          document.body.style.cursor = "col-resize";
          document.body.style.userSelect = "none";
          e.preventDefault();
        });

        document.addEventListener("mousemove", (e) => {
          if (!isResizing) return;
          setEditorWidth(e.clientX);
          mm.fit();
        });

        document.addEventListener("mouseup", () => {
          if (isResizing) {
            isResizing = false;
            resizeHandle.classList.remove("dragging");
            document.body.style.cursor = "";
            document.body.style.userSelect = "";
          }
        });

        editorTextarea.addEventListener("input", () => {
          if (!codeMirrorInitialized) {
            handleEditorInput();
          }
        });

        document.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "f") {
            if (editorVisible && codeMirrorInitialized && codeMirror) {
              e.preventDefault();
              codeMirror.focus();
              codeMirror.execCommand("find");
              return;
            }
          }
          if ((e.ctrlKey || e.metaKey) && e.key === "e") {
            e.preventDefault();
            toggleEditor();
          }
          if (e.key === "Escape" && editorVisible) {
            toggleEditor(false);
          }
        });

        setEditorWidth(editorWidth);

        const turndownService = new window.TurndownService({
          headingStyle: "atx",
          codeBlockStyle: "fenced",
          bulletListMarker: "-",
        });

        function markmapNormalize(mdText) {
          let s = (mdText || "").replace(/\r\n/g, "\n");
          const trimmed = s.trim();
          const fenced = trimmed.match(/^```(?:markdown|md)\s*\n([\s\S]*?)\n```$/);
          if (fenced) s = fenced[1];
          s = s
            .replace(/^(.+)\n=+\s*$/gm, (_, t) => `# ${t.trim()}`)
            .replace(/^(.+)\n-+\s*$/gm, (_, t) => `## ${t.trim()}`);

          const isDiagramFence = (line) =>
            /^```(?:mermaid|dot|graphviz|gv|wavedrom|wave|wavejson|vega-lite|vl)\b/.test(line);
          const isTopLevelDiagramFence = (line) =>
            isDiagramFence(line.trim()) && line.trim() === line;

          const fixedLines = s.split("\n");
          const result = [];
          let lastHeadingLevel = 3;
          let lastExplicitHeadingLevel = 3;
          let needsSeparatorForList = false;
          let prevNonEmptyWasList = false;
          let inFence = false;
          let fenceMarker = null;
          let inMathBlock = false;

          const isFenceLine = (line) => /^\s*(```+|~~~+)/.test(line);
          const isListLine = (line) => /^(\s*)(?:[-*+]|[0-9]+\.)\s+/.test(line);
          const isBlockMathLine = (line) => line.trim().startsWith("$$");
          const isHorizontalRule = (line) => /^([-*_]){3,}\s*$/.test(line.trim());
          const isTableLine = (line) => /^\s*\|/.test(line);
          const isBlockquoteLine = (line) => /^\s*>/.test(line);
          const isHtmlBlockLine = (line) => /^\s*</.test(line);

          for (let i = 0; i < fixedLines.length; i++) {
            const line = fixedLines[i];
            const nextLine = fixedLines[i + 1] || "";

            const fenceMatch = line.match(/^\s*(```+|~~~+)/);
            if (fenceMatch) {
              const marker = fenceMatch[1];
              if (!inFence) {
                inFence = true;
                fenceMarker = marker;
              } else if (line.trim().startsWith(fenceMarker)) {
                inFence = false;
                fenceMarker = null;
              }
              result.push(line);
              prevNonEmptyWasList = false;
              continue;
            }

            if (inFence) {
              result.push(line);
              prevNonEmptyWasList = false;
              continue;
            }

            if (/^\s*\$\$\s*$/.test(line)) {
              inMathBlock = !inMathBlock;
              result.push(line);
              prevNonEmptyWasList = false;
              continue;
            }

            if (inMathBlock) {
              result.push(line);
              prevNonEmptyWasList = false;
              continue;
            }

            const headingMatch = line.match(/^(#{1,6})\s+/);
            if (headingMatch) {
              lastHeadingLevel = headingMatch[1].length;
              lastExplicitHeadingLevel = lastHeadingLevel;
              prevNonEmptyWasList = false;

              let hasListAfter = false;
              let hasMermaidAfter = false;

              for (let j = i + 1; j < fixedLines.length; j++) {
                const rawCheckLine = fixedLines[j];
                const checkLine = rawCheckLine.trim();
                if (checkLine === "") continue;

                if (checkLine.match(/^[-*+]\s+/)) {
                  hasListAfter = true;
                } else if (isTopLevelDiagramFence(rawCheckLine) && hasListAfter) {
                  hasMermaidAfter = true;
                  break;
                } else if (checkLine.match(/^#{1,6}\s+/)) {
                  break;
                }
              }

              result.push(line);

              if (hasListAfter && hasMermaidAfter) {
                needsSeparatorForList = true;
                result.push("");
                const separatorLevel = Math.min(lastHeadingLevel + 1, 6);
                result.push("#".repeat(separatorLevel) + " Details");
                result.push("");
              } else if (hasListAfter) {
                if (nextLine.match(/^[-*+]\s+/)) {
                  result.push("");
                }
              }
              continue;
            }

            const listMatch = line.match(/^(\s*)[-*+]\s+/);
            if (listMatch && needsSeparatorForList) {
              result.push(line);
              prevNonEmptyWasList = true;
              continue;
            }

            const isFreeformLine =
              line.trim() &&
              !isListLine(line) &&
              !isBlockMathLine(line) &&
              !isTableLine(line) &&
              !isBlockquoteLine(line) &&
              !isHtmlBlockLine(line) &&
              !isHorizontalRule(line) &&
              !(prevNonEmptyWasList && /^\s{2,}\S/.test(line));

            if (isFreeformLine) {
              let para = line.trim();
              let j = i + 1;
              while (j < fixedLines.length) {
                const next = fixedLines[j];
                if (!next.trim()) break;
                if (
                  isFenceLine(next) ||
                  isListLine(next) ||
                  isBlockMathLine(next) ||
                  isTableLine(next) ||
                  isBlockquoteLine(next) ||
                  isHtmlBlockLine(next) ||
                  isHorizontalRule(next) ||
                  next.match(/^(#{1,6})\s+/)
                ) {
                  break;
                }
                para += " " + next.trim();
                j++;
              }

              const level = Math.min(lastExplicitHeadingLevel + 1, 6);
              result.push("#".repeat(level) + " " + para);
              lastHeadingLevel = level;
              needsSeparatorForList = false;
              prevNonEmptyWasList = false;
              i = j - 1;
              continue;
            }

            if (needsSeparatorForList && isTopLevelDiagramFence(line)) {
              const separatorLevel = Math.min(lastHeadingLevel + 1, 6);
              result.push("");
              result.push("#".repeat(separatorLevel) + " Diagram");
              result.push("");
              needsSeparatorForList = false;
            }

            result.push(line);
            if (line.trim()) {
              prevNonEmptyWasList = isListLine(line);
            }
          }

          s = result.join("\n");
          return s.replace(/\n{3,}/g, "\n\n").trim() + "\n";
        }

        function computeSafeIndent(indent, mdText, matchIndex) {
          if (indent.length < 4) return indent;
          const before = mdText.slice(0, matchIndex);
          const lines = before.split("\n");
          for (let k = lines.length - 1; k >= 0; k--) {
            const line = lines[k];
            if (!line.trim()) continue;
            if (/^\s*([-*+]\s+|\d+\.\s+)/.test(line)) return indent;
            break;
          }
          return indent.slice(0, 3);
        }

        function getListContext(mdText, matchIndex) {
          const before = mdText.slice(0, matchIndex);
          const lines = before.split("\n");
          for (let k = lines.length - 1; k >= 0; k--) {
            const line = lines[k];
            if (!line.trim()) continue;
            const m = line.match(/^(\s*)(?:[-*+]\s+|\d+\.\s+)/);
            if (m) {
              const indent = m[1] || "";
              return { isList: true, indent, childIndent: indent + "  " };
            }
            break;
          }
          return { isList: false, indent: "", childIndent: "" };
        }

        function appendInlineToLastListItem(out, html) {
          let end = out.length;
          let idx = out.lastIndexOf("\n");
          while (idx >= 0) {
            const line = out.slice(idx + 1, end);
            if (!line.trim()) {
              end = idx;
              idx = out.lastIndexOf("\n", idx - 1);
              continue;
            }
            if (/^\s*(?:[-*+]\s+|\d+\.\s+)[^\n]*$/.test(line)) {
              return out.slice(0, idx + 1) + line + " " + html;
            }
            return null;
          }
          if (/^\s*(?:[-*+]\s+|\d+\.\s+)[^\n]*$/.test(out)) {
            return out + " " + html;
          }
          return null;
        }

        let renderedOnce = false;
        let pending = 0;

        const nextFrame = () => new Promise((r) => requestAnimationFrame(r));
        const nextFrames = async (n) => {
          for (let i = 0; i < n; i++) await nextFrame();
        };
        const preloadImages = async (urls, token) => {
          if (!urls?.length) return;
          for (const url of urls) {
            if (token !== pending) return;
            await new Promise((resolve) => {
              const img = new Image();
              img.onload = () => resolve();
              img.onerror = () => resolve();
              img.src = url;
            });
          }
        };

        function hideOverlayOnce() {
          if (!renderedOnce) {
            overlayEl.classList.add("hidden");
            renderedOnce = true;

            if (pasteEl.value) {
              setEditorValue(pasteEl.value);
            }
          }
        }

        let mermaidInitialized = false;
        let mermaidId = 0;
        let activeBlobUrls = [];

        function ensureMermaidInit() {
          if (mermaidInitialized) return;
          window.mermaid.initialize({
            startOnLoad: false,
            htmlLabels: false,
            markdownAutoWrap: true,
            wrap: true,
            flowchart: {
              htmlLabels: false,
              useMaxWidth: false,
              wrappingWidth: 340,
            },
          });
          mermaidInitialized = true;
        }

        function parseSvgSize(svgText) {
          const vbMatch = svgText.match(/viewBox=['"]([^'"]+)['"]/i);
          if (vbMatch) {
            const parts = vbMatch[1].trim().split(/\s+/).map(Number);
            if (parts.length === 4 && parts.every(Number.isFinite)) {
              const width = Math.max(1, Math.ceil(parts[2]));
              const height = Math.max(1, Math.ceil(parts[3]));
              return { width, height };
            }
          }

          const widthMatch = svgText.match(/width=['"]([^'"]+)['"]/i);
          const heightMatch = svgText.match(/height=['"]([^'"]+)['"]/i);
          if (widthMatch && heightMatch) {
            const width = Math.max(1, Math.ceil(parseFloat(widthMatch[1])));
            const height = Math.max(1, Math.ceil(parseFloat(heightMatch[1])));
            if (Number.isFinite(width) && Number.isFinite(height)) return { width, height };
          }

          return { width: 480, height: 240 };
        }

        function revokeBlobs(urls) {
          if (!urls?.length) return;
          for (const url of urls) {
            try {
              URL.revokeObjectURL(url);
            } catch {}
          }
        }

        function injectSvgStyle(svgText, styleText) {
          if (!styleText) return svgText;
          if (/<style[^>]*>/i.test(svgText)) {
            return svgText.replace(/<style[^>]*>/i, (m) => m + styleText);
          }
          return svgText.replace(/<svg\b[^>]*>/i, (m) => `${m}<style>${styleText}</style>`);
        }

        function setSvgPixelSize(svgText, width, height) {
          return svgText.replace(/<svg\b([^>]*)>/i, (full, attrs) => {
            let next = attrs
              .replace(/\swidth=\"[^\"]*\"/i, "")
              .replace(/\sheight=\"[^\"]*\"/i, "")
              .replace(/\sstyle=\"[^\"]*\"/i, "");
            return `<svg${next} width="${width}" height="${height}" style="width:${width}px;height:${height}px;">`;
          });
        }

        function getRasterScale() {
          const dpr = window.devicePixelRatio || 1;
          return Math.max(1, Math.min(2, dpr));
        }

        function collectBlobUrls(text) {
          const urls = [];
          const re = /src=['"](blob:[^'"]+)['"]/g;
          let match;
          while ((match = re.exec(text))) {
            urls.push(match[1]);
          }
          return urls;
        }

        async function svgToPngBlob(svgText, width, height, scale = 1) {
          const svgBlob = new Blob([svgText], { type: "image/svg+xml" });
          const url = URL.createObjectURL(svgBlob);
          try {
            const img = new Image();
            img.decoding = "async";
            const loadPromise = new Promise((resolve, reject) => {
              img.onload = () => resolve();
              img.onerror = (err) => reject(err);
            });
            img.src = url;
            if (img.decode) {
              await img.decode().catch(() => loadPromise);
            } else {
              await loadPromise;
            }
            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.ceil(width * scale));
            canvas.height = Math.max(1, Math.ceil(height * scale));
            const ctx = canvas.getContext("2d");
            if (!ctx) throw new Error("Canvas is not available");
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            return await new Promise((resolve, reject) => {
              canvas.toBlob((blob) => {
                if (blob) resolve(blob);
                else reject(new Error("Canvas PNG export failed"));
              }, "image/png");
            });
          } finally {
            URL.revokeObjectURL(url);
          }
        }

        function renderInlineMarkdown(text) {
          if (transformer?.md?.renderInline) return transformer.md.renderInline(text);
          const parts = text.split(/(<img[^>]*>)/gi);
          return parts
            .map((part) => {
              if (/^<img/i.test(part)) return part;
              return part.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            })
            .join("");
        }

        async function renderHtmlLineToPng(html) {
          const baseStyle = getComputedStyle(document.body);
          const fontSize = parseFloat(baseStyle.fontSize) || 16;
          const lineHeight = parseFloat(baseStyle.lineHeight);
          const normalizedLineHeight = Number.isFinite(lineHeight)
            ? lineHeight
            : Math.round(fontSize * 1.2);
          const baseFont = `${baseStyle.fontStyle} ${baseStyle.fontWeight} ${fontSize}px ${baseStyle.fontFamily}`;
          const codeFont = `${baseStyle.fontStyle} ${baseStyle.fontWeight} ${fontSize}px ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;
          const scale = getRasterScale();

          const container = document.createElement("div");
          container.innerHTML = html;
          const tokens = [];

          const walk = (node, inCode) => {
            if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent || "";
              if (text) tokens.push({ type: "text", text, font: inCode ? codeFont : baseFont });
              return;
            }
            if (node.nodeType !== Node.ELEMENT_NODE) return;
            const el = node;
            const tag = el.tagName.toLowerCase();
            if (tag === "img") {
              const width = parseFloat(el.getAttribute("width") || "") || 0;
              const height = parseFloat(el.getAttribute("height") || "") || 0;
              tokens.push({ type: "img", src: el.getAttribute("src") || "", width, height });
              return;
            }
            if (tag === "code") {
              Array.from(el.childNodes).forEach((child) => walk(child, true));
              return;
            }
            if (tag === "br") {
              tokens.push({ type: "text", text: " ", font: inCode ? codeFont : baseFont });
              return;
            }
            Array.from(el.childNodes).forEach((child) => walk(child, inCode));
          };

          Array.from(container.childNodes).forEach((child) => walk(child, false));

          const imgTokens = tokens.filter((token) => token.type === "img" && token.src);
          const imgCache = new Map();
          await Promise.all(
            imgTokens.map((token) => {
              if (imgCache.has(token.src)) return Promise.resolve();
              return new Promise((resolve) => {
                const img = new Image();
                img.decoding = "async";
                img.onload = () => resolve();
                img.onerror = () => resolve();
                img.src = token.src;
                imgCache.set(token.src, img);
              });
            })
          );

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          if (!ctx) throw new Error("Canvas is not available");
          ctx.textBaseline = "alphabetic";
          ctx.fillStyle = baseStyle.color;

          const paddingX = 2;
          const paddingY = 4;
          const imgAscentRatio = 0.8;
          const imgDescentRatio = 0.2;
          let totalWidth = 0;
          let maxAscent = normalizedLineHeight * 0.8;
          let maxDescent = normalizedLineHeight * 0.2;
          for (const token of tokens) {
            if (token.type === "text") {
              ctx.font = token.font;
              const width = ctx.measureText(token.text).width;
              token.width = width;
              const metrics = ctx.measureText(token.text);
              const ascent = Number.isFinite(metrics.actualBoundingBoxAscent)
                ? metrics.actualBoundingBoxAscent
                : normalizedLineHeight * 0.8;
              const descent = Number.isFinite(metrics.actualBoundingBoxDescent)
                ? metrics.actualBoundingBoxDescent
                : normalizedLineHeight * 0.2;
              maxAscent = Math.max(maxAscent, ascent);
              maxDescent = Math.max(maxDescent, descent);
              totalWidth += width;
            } else if (token.type === "img") {
              const img = imgCache.get(token.src);
              const width = token.width || img?.naturalWidth || 0;
              const height = token.height || img?.naturalHeight || 0;
              token.width = width;
              token.height = height;
              totalWidth += width;
              maxAscent = Math.max(maxAscent, height * imgAscentRatio);
              maxDescent = Math.max(maxDescent, height * imgDescentRatio);
            }
          }

          const width = Math.max(1, Math.ceil(totalWidth + paddingX * 2));
          const height = Math.max(1, Math.ceil(maxAscent + maxDescent + paddingY * 2));
          canvas.width = Math.max(1, Math.ceil(width * scale));
          canvas.height = Math.max(1, Math.ceil(height * scale));
          ctx.scale(scale, scale);

          let x = paddingX;
          const baselineY = paddingY + maxAscent;
          for (const token of tokens) {
            if (token.type === "text") {
              ctx.font = token.font;
              ctx.fillStyle = baseStyle.color;
              ctx.fillText(token.text, x, baselineY);
              x += token.width || 0;
            } else if (token.type === "img") {
              const img = imgCache.get(token.src);
              const w = token.width || 0;
              const h = token.height || 0;
              if (img && w > 0 && h > 0) {
                const y = baselineY - h * imgAscentRatio;
                ctx.drawImage(img, x, y, w, h);
              }
              x += w;
            }
          }

          const blob = await new Promise((resolve, reject) => {
            canvas.toBlob((out) => {
              if (out) resolve(out);
              else reject(new Error("Canvas PNG export failed"));
            }, "image/png");
          });
          return { blob, width, height };
        }

        function parseSvgSizeWithUnit(svgText, basePx) {
          const widthMatch = svgText.match(/width=\"([^\"]+)\"/i);
          const heightMatch = svgText.match(/height=\"([^\"]+)\"/i);
          if (!widthMatch || !heightMatch) return null;

          const parseSize = (value) => {
            const num = parseFloat(value);
            if (!Number.isFinite(num)) return null;
            const unit = String(value)
              .replace(/[0-9.\s]/g, "")
              .toLowerCase();
            if (!unit || unit === "px") return num;
            if (unit === "em") return num * basePx;
            if (unit === "ex") return num * basePx * 0.5;
            if (unit === "in") return num * 96;
            if (unit === "pt") return num * (96 / 72);
            if (unit === "cm") return num * (96 / 2.54);
            if (unit === "mm") return num * (96 / 25.4);
            return null;
          };

          const width = parseSize(widthMatch[1]);
          const height = parseSize(heightMatch[1]);
          if (!Number.isFinite(width) || !Number.isFinite(height)) return null;
          return { width: Math.max(1, Math.ceil(width)), height: Math.max(1, Math.ceil(height)) };
        }

        async function preRenderMathToImages(mdText, currentToken) {
          if (!window.MathJax?.tex2svg) return { mdOut: mdText, blobUrls: [] };
          if (window.MathJax?.startup?.promise) {
            try {
              await window.MathJax.startup.promise;
            } catch {}
          }
          try {
            if (document.fonts?.ready) await document.fonts.ready;
          } catch {}
          if (currentToken !== pending) return null;

          const blobUrls = [];
          let out = "";
          let i = 0;
          let inFence = false;
          let fence = "";
          let inInlineCode = false;
          let inlineCodeTicks = 0;

          const isLineStart = (pos) => pos === 0 || mdText[pos - 1] === "\n";
          const readLine = (pos) => {
            const end = mdText.indexOf("\n", pos);
            return {
              text: end === -1 ? mdText.slice(pos) : mdText.slice(pos, end),
              end: end === -1 ? mdText.length : end + 1,
            };
          };

          const countTickRun = (pos) => {
            let n = 0;
            while (mdText[pos + n] === "`") n += 1;
            return n;
          };

          const shouldRenderInlineMath = (expr) => {
            const trimmed = (expr || "").trim();
            if (!trimmed) return false;
            const currencyLike =
              /^\d[\d,]*(?:\.\d+)?(?:\s*(?:k|m|b|bn|mm|t))?(?:\s*(?:usd|eur|gbp|cad|aud|jpy|inr))?(?:\s*(?:to|–|-)\s*\d[\d,]*(?:\.\d+)?(?:\s*(?:k|m|b|bn|mm|t))?(?:\s*(?:usd|eur|gbp|cad|aud|jpy|inr))?)?$/i;
            if (currencyLike.test(trimmed)) return false;
            if (/[\\^_{}=]/.test(trimmed)) return true;
            return /[A-Za-z]/.test(trimmed);
          };

          const renderMathImg = async (expr, displayMode, indent, matchIndex) => {
            if (!displayMode && !shouldRenderInlineMath(expr)) return null;
            let svg = "";
            try {
              const svgNode = window.MathJax.tex2svg(expr, { display: displayMode });
              const svgEl = svgNode?.querySelector?.("svg");
              svg = svgEl ? svgEl.outerHTML : "";
            } catch (e) {
              console.warn("MathJax render failed; skipping block", e);
              return null;
            }

            if (!svg) return null;

            const basePx = parseFloat(getComputedStyle(document.body).fontSize) || 16;
            const sized = parseSvgSizeWithUnit(svg, basePx);
            const size = sized || parseSvgSize(svg) || { width: 120, height: 40 };
            svg = setSvgPixelSize(svg, size.width, size.height);
            const rasterScale = getRasterScale();
            let blob;
            try {
              blob = await svgToPngBlob(svg, size.width, size.height, rasterScale);
            } catch (e) {
              console.warn("MathJax rasterize failed; skipping block", e);
              return null;
            }
            const url = URL.createObjectURL(blob);
            blobUrls.push(url);
            const imgClass = displayMode ? "math-img math-block" : "math-img";
            const img = `<img class="${imgClass}" alt="math" src="${url}" width="${size.width}" height="${size.height}" style="width:${size.width}px;height:${size.height}px;">`;
            if (displayMode) {
              const listItemMatch = indent.match(/^(\s*(?:[-*+]\s+|\d+\.\s+))/);
              if (listItemMatch) {
                return img;
              }
              const useListCtx = indent.length > 0;
              const listCtx = useListCtx ? getListContext(mdText, matchIndex) : { isList: false };
              const safeIndent = listCtx.isList
                ? listCtx.childIndent
                : computeSafeIndent(indent, mdText, matchIndex);
              if (listCtx.isList) {
                const inlineOut = appendInlineToLastListItem(out, img);
                if (inlineOut !== null) {
                  out = inlineOut;
                  return "";
                }
                return `${safeIndent}${img}`;
              }
              return `${safeIndent}- ${img}`;
            }
            return img;
          };

          const findClosingDollar = (start, isDouble) => {
            const needle = isDouble ? "$$" : "$";
            for (let pos = start; pos < mdText.length; pos++) {
              if (mdText[pos] === "\\") {
                pos += 1;
                continue;
              }
              if (mdText.startsWith(needle, pos)) return pos;
            }
            return -1;
          };

          while (i < mdText.length) {
            if (!inFence && isLineStart(i)) {
              const line = readLine(i);
              const m = line.text.match(/^([ \t]*)(```|~~~)/);
              if (m) {
                inFence = true;
                fence = m[2];
                out += line.text + "\n";
                i = line.end;
                continue;
              }
            }

            if (inFence && isLineStart(i)) {
              const line = readLine(i);
              if (line.text.trim().startsWith(fence)) {
                inFence = false;
                fence = "";
                out += line.text + "\n";
                i = line.end;
                continue;
              }
            }

            if (inFence) {
              out += mdText[i++];
              continue;
            }

            if (!inInlineCode && mdText[i] === "`") {
              const run = countTickRun(i);
              inInlineCode = true;
              inlineCodeTicks = run;
              out += mdText.slice(i, i + run);
              i += run;
              continue;
            }
            if (inInlineCode) {
              if (mdText[i] === "`") {
                const run = countTickRun(i);
                out += mdText.slice(i, i + run);
                i += run;
                if (run >= inlineCodeTicks) {
                  inInlineCode = false;
                  inlineCodeTicks = 0;
                }
                continue;
              }
              out += mdText[i++];
              continue;
            }

            if (mdText[i] === "$" && mdText[i + 1] === "$") {
              const lineStart = mdText.lastIndexOf("\n", i - 1) + 1;
              const line = readLine(lineStart);
              const indent = mdText.slice(lineStart, i);
              const lineContent = line.text.replace(/^\s*(?:[-*+]\s+|\d+\.\s+)?/, "");
              const isLineBlock = /^\$\$[\s\S]*\$\$\s*$/.test(lineContent);
              const isBlock = isLineBlock || /^[ \t]*$/.test(indent);
              const end = findClosingDollar(i + 2, true);
              if (end === -1) {
                out += mdText[i++];
                continue;
              }
              const expr = mdText.slice(i + 2, end).trim();
              const img = await renderMathImg(expr, isBlock, indent, i);
              if (currentToken !== pending) {
                revokeBlobs(blobUrls);
                return null;
              }
              if (img !== null) out += img;
              else out += mdText.slice(i, end + 2);
              i = end + 2;
              continue;
            }

            if (mdText[i] === "$") {
              const end = findClosingDollar(i + 1, false);
              if (end === -1) {
                out += mdText[i++];
                continue;
              }
              const expr = mdText.slice(i + 1, end);
              const img = await renderMathImg(expr, false, "", i);
              if (currentToken !== pending) {
                revokeBlobs(blobUrls);
                return null;
              }
              if (img !== null) out += img;
              else out += mdText.slice(i, end + 1);
              i = end + 1;
              continue;
            }

            out += mdText[i++];
          }

          return { mdOut: out, blobUrls };
        }

        async function preRenderMathLinesToImages(mdText, mathBlobUrls, currentToken) {
          if (!mdText.includes("math-img")) return { mdOut: mdText, blobUrls: mathBlobUrls || [] };

          const lines = mdText.split("\n");
          const outLines = [];
          let inFence = false;
          let fence = "";
          const lineBlobUrls = [];

          for (let i = 0; i < lines.length; i += 1) {
            const line = lines[i];
            if (!inFence) {
              const m = line.match(/^([ \t]*)(```|~~~)/);
              if (m) {
                inFence = true;
                fence = m[2];
                outLines.push(line);
                continue;
              }
            } else {
              if (line.trim().startsWith(fence)) {
                inFence = false;
                fence = "";
              }
              outLines.push(line);
              continue;
            }

            const listMatch = line.match(/^(\s*(?:[-*+]\s+|\d+\.\s+))(.*)$/);
            if (!listMatch) {
              outLines.push(line);
              continue;
            }

            const block = [];
            let j = i;
            while (j < lines.length) {
              const candidate = lines[j];
              const m = candidate.match(/^(\s*(?:[-*+]\s+|\d+\.\s+))(.*)$/);
              if (!m) break;
              block.push(candidate);
              j += 1;
            }
            i = j - 1;

            const hasInlineMath = block.some(
              (entry) => entry.includes("math-img") && !entry.includes("math-block")
            );
            if (!hasInlineMath) {
              outLines.push(...block);
              continue;
            }

            for (let bi = 0; bi < block.length; bi += 1) {
              const entry = block[bi];
              const entryMatch = entry.match(/^(\s*(?:[-*+]\s+|\d+\.\s+))(.*)$/);
              if (!entryMatch) {
                outLines.push(entry);
                continue;
              }
              const prefix = entryMatch[1];
              const content = entryMatch[2];
              if (content.includes("math-block")) {
                outLines.push(entry);
                continue;
              }

              let html = "";
              try {
                html = renderInlineMarkdown(content);
              } catch (e) {
                console.warn("Math line markdown render failed; keeping text", e);
                outLines.push(entry);
                continue;
              }

              let rendered;
              try {
                rendered = await renderHtmlLineToPng(html);
              } catch (e) {
                console.warn("Math line rasterize failed; keeping text", e);
                outLines.push(entry);
                continue;
              }

              if (currentToken !== pending) {
                revokeBlobs(lineBlobUrls);
                return null;
              }

              const url = URL.createObjectURL(rendered.blob);
              lineBlobUrls.push(url);
              const img = `<img class="math-line-img" alt="math line" src="${url}" width="${rendered.width}" height="${rendered.height}" style="width:${rendered.width}px;height:${rendered.height}px;">`;
              outLines.push(`${prefix}${img}`);
              const nextEntry = block[bi + 1];
              if (nextEntry) {
                const currIndentMatch = entry.match(/^(\s*)/);
                const nextIndentMatch = nextEntry.match(/^(\s*)/);
                const currIndent = currIndentMatch ? currIndentMatch[1].length : 0;
                const nextIndent = nextIndentMatch ? nextIndentMatch[1].length : 0;
                if (nextIndent > currIndent) {
                  outLines.push(" ".repeat(currIndent + 2));
                }
              }
            }
          }

          const mdOut = outLines.join("\n");
          const usedUrls = collectBlobUrls(mdOut);
          const usedSet = new Set(usedUrls);
          for (const url of mathBlobUrls || []) {
            if (!usedSet.has(url)) revokeBlobs([url]);
          }
          for (const url of lineBlobUrls) {
            if (!usedSet.has(url)) revokeBlobs([url]);
          }
          return { mdOut, blobUrls: usedUrls };
        }

        let vizPromise;
        const wavedromScratch = document.createElement("div");
        const vegaScratch = document.createElement("div");
        wavedromScratch.style.position = "fixed";
        wavedromScratch.style.left = "-99999px";
        wavedromScratch.style.top = "-99999px";
        vegaScratch.style.position = "fixed";
        vegaScratch.style.left = "-99999px";
        vegaScratch.style.top = "-99999px";
        document.body.appendChild(wavedromScratch);
        document.body.appendChild(vegaScratch);

        function getViz() {
          if (!window.Viz?.instance) throw new Error("Viz.js is not available");
          return (vizPromise ??= window.Viz.instance());
        }

        function stripFirstDirective(src, re) {
          const lines = src.split("\n");
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            const m = line.match(re);
            if (m) {
              lines.splice(i, 1);
              return { value: m[1], body: lines.join("\n") };
            }
            return { value: null, body: src };
          }
          return { value: null, body: src };
        }

        const renderers = {
          mermaid: {
            name: "Mermaid",
            render: async (src) => {
              ensureMermaidInit();
              try {
                if (document.fonts?.ready) await document.fonts.ready;
              } catch {}
              const isERDiagram = /^\s*erDiagram\b/m.test(src);
              const cleaned = sanitizeMermaidSourceLabels(src, {
                lineBreak: "\n",
                preserveExisting: true,
                normalizeHtmlEntities: true,
                useNamedColon: true,
                useMarkdownStrings: true,
                wrapEdgeLabels: !isERDiagram,
              });

              const result = await window.mermaid.render(`mermaid-pre-${++mermaidId}`, cleaned);
              let svg = result?.svg || "";
              if (!svg) throw new Error("Mermaid output missing");
              if (isERDiagram) {
                svg = injectSvgStyle(svg, ".edgeLabel text{fill:#fff;}");
              }
              const size = parseSvgSize(svg);
              return {
                mime: "image/svg+xml",
                data: svg,
                width: size.width,
                height: size.height,
                className: "diagram-img mermaid-img",
                alt: "mermaid diagram",
              };
            },
          },
          dot: {
            name: "DOT",
            render: async (src) => {
              const { value: engine, body } = stripFirstDirective(
                src,
                /^\s*(?:\/\/|#)\s*engine:\s*([A-Za-z0-9_-]+)/i
              );
              const viz = await getViz();
              const svgEl = viz.renderSVGElement(body, engine ? { engine } : undefined);
              const svg = new XMLSerializer().serializeToString(svgEl);
              const size = parseSvgSizeWithUnit(svg, 16) || parseSvgSize(svg);
              return {
                mime: "image/svg+xml",
                data: svg,
                width: size.width,
                height: size.height,
                className: "diagram-img dot-img",
                alt: "dot diagram",
              };
            },
          },
          graphviz: {
            name: "DOT",
            render: async (src, ctx) => renderers.dot.render(src, ctx),
          },
          gv: {
            name: "DOT",
            render: async (src, ctx) => renderers.dot.render(src, ctx),
          },
          wavedrom: {
            name: "WaveDrom",
            render: async (src) => {
              // Known limitation: WaveDrom parsing expects JSON5-ish syntax (via JSON5 parser).
              if (!window.JSON5?.parse) throw new Error("JSON5 parser unavailable");
              if (!window.WaveDrom?.ProcessAll) throw new Error("WaveDrom is not available");
              const obj = window.JSON5.parse(src);
              const normalized = JSON.stringify(obj);
              wavedromScratch.innerHTML = "";
              const script = document.createElement("script");
              script.type = "WaveDrom";
              script.textContent = normalized;
              wavedromScratch.appendChild(script);
              window.WaveDrom.ProcessAll();
              const svgEl = wavedromScratch.querySelector("svg");
              if (!svgEl) throw new Error("WaveDrom output missing");
              const svg = new XMLSerializer().serializeToString(svgEl);
              const size = parseSvgSize(svg);
              return {
                mime: "image/svg+xml",
                data: svg,
                width: size.width,
                height: size.height,
                className: "diagram-img wavedrom-img",
                alt: "wavedrom diagram",
              };
            },
          },
          wave: {
            name: "WaveDrom",
            render: async (src, ctx) => renderers.wavedrom.render(src, ctx),
          },
          wavejson: {
            name: "WaveDrom",
            render: async (src, ctx) => renderers.wavedrom.render(src, ctx),
          },
          "vega-lite": {
            name: "Vega-Lite",
            render: async (src, ctx) => {
              if (!window.vegaEmbed) throw new Error("Vega-Embed is not available");
              const parser = window.JSON5?.parse || JSON.parse;
              const spec = parser(src);
              vegaScratch.innerHTML = "";

              // Known limitation: Vega charts are exported as images (no interactivity).
              const res = await window.vegaEmbed(vegaScratch, spec, {
                actions: false,
                renderer: "svg",
              });
              const svg = await res.view.toSVG();
              res.view.finalize();
              const size = parseSvgSize(svg);
              return {
                mime: "image/svg+xml",
                data: svg,
                width: size.width,
                height: size.height,
                className: "diagram-img vega-img",
                alt: "vega-lite chart",
              };
            },
          },
          vl: {
            name: "Vega-Lite",
            render: async (src, ctx) => renderers["vega-lite"].render(src, ctx),
          },
        };

        async function preRenderDiagramFencesToImages(mdText, currentToken) {
          const re =
            /^([ \t]*)```([A-Za-z0-9_-]+)(?:[ \t]+([A-Za-z0-9_-]+))?[ \t]*\n([\s\S]*?)\n\1```/gim;
          let out = "";
          let lastIndex = 0;
          let match;
          const blobUrls = [];

          while ((match = re.exec(mdText)) !== null) {
            out += mdText.slice(lastIndex, match.index);
            const indent = match[1] || "";
            const lang = (match[2] || "").toLowerCase();
            const hint = (match[3] || "").toLowerCase();
            const raw = match[4] || "";
            const renderer = renderers[lang];
            const listCtx = getListContext(mdText, match.index);
            const safeIndent = listCtx.isList
              ? listCtx.childIndent
              : computeSafeIndent(indent, mdText, match.index);

            if (!renderer) {
              out += match[0];
              lastIndex = re.lastIndex;
              continue;
            }

            if (currentToken !== pending) {
              revokeBlobs(blobUrls);
              return null;
            }

            let rendered;
            try {
              rendered = await renderer.render(raw, {
                mdText,
                matchIndex: match.index,
                token: currentToken,
                formatHint: hint,
              });
            } catch (e) {
              const firstLine = raw.split("\n").find((line) => line.trim()) || "";
              console.warn(`${renderer.name} render failed; skipping block`, firstLine, e);
              out += match[0];
              lastIndex = re.lastIndex;
              continue;
            }

            if (!rendered || currentToken !== pending) {
              revokeBlobs(blobUrls);
              return null;
            }

            const { mime, data, width, height, className, alt } = rendered;
            if (!mime || !data) {
              out += match[0];
              lastIndex = re.lastIndex;
              continue;
            }

            const blob = data instanceof Blob ? data : new Blob([data], { type: mime });
            const url = URL.createObjectURL(blob);
            blobUrls.push(url);
            const finalWidth = Number.isFinite(width) && width > 0 ? Math.ceil(width) : 480;
            const finalHeight = Number.isFinite(height) && height > 0 ? Math.ceil(height) : 240;
            const imgClass = className || "diagram-img";
            const imgAlt = alt || `${renderer.name} diagram`;
            const imgHtml = `<img class="${imgClass}" alt="${imgAlt}" src="${url}" width="${finalWidth}" height="${finalHeight}" style="width:${finalWidth}px;height:${finalHeight}px;">`;
            if (listCtx.isList) {
              const inlineOut = appendInlineToLastListItem(out, imgHtml);
              if (inlineOut !== null) {
                out = inlineOut;
              } else {
                out += `${safeIndent}${imgHtml}`;
              }
            } else {
              out += `${safeIndent}- ${imgHtml}`;
            }
            lastIndex = re.lastIndex;
          }

          out += mdText.slice(lastIndex);
          return { mdOut: out, blobUrls };
        }

        async function render(mdText) {
          const text = (mdText || "").trim();
          if (!text) return;

          const token = ++pending;
          try {
            const normalized = markmapNormalize(text);
            const mathPre = await preRenderMathToImages(normalized, token);
            if (!mathPre || token !== pending) return;
            const mathLinePre = await preRenderMathLinesToImages(
              mathPre.mdOut,
              mathPre.blobUrls,
              token
            );
            if (!mathLinePre || token !== pending) {
              revokeBlobs(mathPre.blobUrls);
              return;
            }
            const diagramPre = await preRenderDiagramFencesToImages(mathLinePre.mdOut, token);
            if (!diagramPre || token !== pending) {
              revokeBlobs(mathLinePre.blobUrls);
              return;
            }
            revokeBlobs(activeBlobUrls);
            activeBlobUrls = [...mathLinePre.blobUrls, ...diagramPre.blobUrls];

            const { root } = transformer.transform(diagramPre.mdOut);
            await preloadImages(activeBlobUrls, token);
            if (token !== pending) return;
            await mm.setData(root);

            await nextFrames(2);
            if (token !== pending) return;

            mm.fit();

            hideOverlayOnce();
          } catch (e) {
            console.error("Render failed:", e);
            alert("Render error: " + (e?.message || String(e)));
          }
        }

        function looksLikeMarkdown(s) {
          const t = (s || "").trim();
          if (!t) return false;
          return (
            /(^|\n)\s{0,3}#{1,6}\s+\S/.test(t) ||
            /(^|\n)\s{0,3}[-*+]\s+\S/.test(t) ||
            /(^|\n)\s{0,3}\d+\.\s+\S/.test(t)
          );
        }

        function clipboardToMarkmapMdFromDataTransfer(dt) {
          const html = dt?.getData("text/html") || "";
          const plain = dt?.getData("text/plain") || "";

          if (looksLikeMarkdown(plain)) return markmapNormalize(plain);

          if (html && html.trim()) {
            try {
              const converted = turndownService.turndown(html);
              const normalized = markmapNormalize(converted);
              if (normalized.trim()) return normalized;
            } catch (e) {
              console.warn("Turndown failed; fallback to plain", e);
            }
          }
          return markmapNormalize(plain);
        }

        async function getPasteMarkdown(dataTransfer, fallbackOnly = false) {
          if (!fallbackOnly && dataTransfer) {
            const mdText = clipboardToMarkmapMdFromDataTransfer(dataTransfer);
            if (mdText.trim()) return mdText;
          }
          return markmapNormalize(await getPasteTextFallback());
        }

        async function getPasteTextFallback() {
          try {
            return (await navigator.clipboard.readText()) || "";
          } catch {
            return "";
          }
        }

        function applyPasteText(mdText, replaceAll = true) {
          if (!mdText.trim()) return;

          if (replaceAll) {
            pasteEl.value = mdText;
          } else {
            const start = pasteEl.selectionStart ?? pasteEl.value.length;
            const end = pasteEl.selectionEnd ?? start;
            try {
              pasteEl.setRangeText(mdText, start, end, "end");
            } catch {
              pasteEl.value += mdText;
            }
          }
          queueMicrotask(() => render(pasteEl.value));
        }

        pasteEl.addEventListener("paste", async (ev) => {
          ev.preventDefault();
          const mdText = await getPasteMarkdown(ev.clipboardData);
          applyPasteText(mdText, true);
          pasteEl.focus();
        });

        pasteEl.addEventListener("beforeinput", async (ev) => {
          if (ev.inputType !== "insertFromPaste") return;
          ev.preventDefault();
          const mdText = await getPasteMarkdown(null, true);
          applyPasteText(mdText, true);
          pasteEl.focus();
        });

        document.addEventListener(
          "paste",
          async (ev) => {
            if (ev.target === pasteEl) return;
            if (editorPanel.contains(ev.target)) return;
            ev.preventDefault();
            const mdText = await getPasteMarkdown(ev.clipboardData);
            applyPasteText(mdText, true);
            pasteEl.focus();
          },
          true
        );

        let t = null;
        pasteEl.addEventListener("input", () => {
          clearTimeout(t);
          t = setTimeout(() => render(pasteEl.value), 50);
        });

        exampleBtn.addEventListener("click", () => {
          const mdText = [
            "# Renderers Test",
            "",
            "## Nested list (must stay nested)",
            "- Parent node",
            "    - DOT child",
            "      ```dot",
            "      digraph G { rankdir=LR; A -> B -> C; }",
            "      ```",
            "    - WaveDrom child",
            "      ```wavedrom",
            "      { signal: [",
            '        { name: "clk", wave: "p....." },',
            '        { name: "req", wave: "01..0." },',
            '        { name: "ack", wave: "0.1..0" }',
            '      ], head: { text: "join late data timeline", tick: 0, every: 2 } }',
            "      ```",
            "    - Vega-Lite SVG child",
            "      ```vega-lite",
            "      {",
            '        "$schema": "https://vega.github.io/schema/vega-lite/v6.json",',
            '        "width": 260,',
            '        "height": 160,',
            '        "data": { "values": [',
            '          {"k":"A","v":28}, {"k":"B","v":55}, {"k":"C","v":43}',
            "        ]},",
            '        "mark": "bar",',
            '        "encoding": {',
            '          "x": {"field":"k","type":"nominal"},',
            '          "y": {"field":"v","type":"quantitative"}',
            "        }",
            "      }",
            "      ```",
            "",
            "## Mermaid baseline",
            "```mermaid",
            "flowchart LR",
            '  A["`hello`"] --> B["`world`"]',
            "```",
          ].join("\n");
          pasteEl.value = mdText;
          render(mdText);
        });

        window.addEventListener("resize", () => mm.fit());
        window.addEventListener("load", () => pasteEl.focus());
      })();
    </script>
  </body>
</html>
