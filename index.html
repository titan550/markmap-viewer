<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Paste → Markmap (+ Mermaid)</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/style.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/theme/dracula.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/dialog/dialog.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">

  <style>
    :root {
      color-scheme: light dark;
      --mermaid-label-max: 340px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { overflow: hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    #mindmap { width: 100vw; height: 100vh; display: block; }

    .overlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      padding: 16px;
      background: rgba(0,0,0,.05);
      transition: opacity .15s ease;
      z-index: 10;
    }
    .card {
      width: min(680px, 100%);
      border: 1px solid rgba(127,127,127,.35);
      border-radius: 12px;
      padding: 18px;
      background: rgba(255,255,255,.92);
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
    }
    @media (prefers-color-scheme: dark) {
      .overlay { background: rgba(0,0,0,.35); }
      .card { background: rgba(24,24,27,.92); }
    }
    h1 { margin: 0 0 10px; font-size: 18px; font-weight: 650; }
    p { margin: 0 0 10px; font-size: 13px; opacity: .8; line-height: 1.4; }
    textarea {
      width: 100%;
      min-height: 170px;
      resize: vertical;
      border-radius: 10px;
      border: 1px solid rgba(127,127,127,.35);
      padding: 10px 11px;
      font: 12.5px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: transparent;
      color: inherit;
      outline: none;
    }
    textarea:focus { border-color: rgba(74,158,255,.9); }

    .hidden { opacity: 0; pointer-events: none; }
    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; margin-top: 10px; }
    .button-group { display: inline-flex; gap: 8px; align-items: center; }
    .hint { font-size: 12px; opacity: .7; }
    button {
      appearance: none;
      border: 1px solid rgba(127,127,127,.35);
      background: transparent;
      color: inherit;
      padding: 7px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12.5px;
    }
    button:hover { background: rgba(127,127,127,.08); }

    #mindmap { overflow: visible; }
    foreignObject { overflow: visible; }
    foreignObject * { overflow: visible; }

    foreignObject pre.mermaid,
    foreignObject pre.mermaid-rendered,
    foreignObject div.mermaid,
    foreignObject div.mermaid-rendered {
      margin: 6px 0 0;
      padding: 0;
      border: 0;
      background: transparent;
      overflow: visible;
      white-space: pre;
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    foreignObject pre.mermaid-rendered,
    foreignObject div.mermaid-rendered {
      white-space: normal;
      font: inherit;
    }

    foreignObject .mermaid-rendered svg {
      display: block;
      overflow: visible;
      height: initial;
      width: initial;
      max-width: none;
    }

    foreignObject .mermaid-rendered .nodeLabel,
    foreignObject .mermaid-rendered .label {
      max-width: var(--mermaid-label-max) !important;
      display: inline-block !important;
      white-space: normal !important;
      overflow-wrap: anywhere !important;
      word-break: break-word !important;
      line-height: 1.25 !important;
    }

    foreignObject .mermaid-rendered .edgeLabel,
    foreignObject .mermaid-rendered .edgeLabel * {
      white-space: normal !important;
      overflow-wrap: anywhere !important;
      word-break: break-word !important;
      line-height: 1.25 !important;
    }

    svg.erDiagram .edgeLabel text {
      fill: #fff !important;
    }

    #toggleEditor {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 100;
      appearance: none;
      border: 1px solid rgba(127,127,127,.35);
      background: rgba(255,255,255,.92);
      color: inherit;
      padding: 8px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
      transition: all .2s ease;
    }
    #toggleEditor:hover {
      background: rgba(255,255,255,1);
      box-shadow: 0 4px 12px rgba(0,0,0,.12);
    }
    @media (prefers-color-scheme: dark) {
      #toggleEditor {
        background: rgba(40,40,43,.92);
        box-shadow: 0 2px 8px rgba(0,0,0,.3);
      }
      #toggleEditor:hover {
        background: rgba(50,50,53,1);
        box-shadow: 0 4px 12px rgba(0,0,0,.4);
      }
    }

    #editorPanel {
      position: fixed;
      left: 0;
      top: 0;
      height: 100vh;
      width: 400px;
      background: rgba(255,255,255,.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(127,127,127,.25);
      box-shadow: 2px 0 12px rgba(0,0,0,.08);
      display: flex;
      flex-direction: column;
      z-index: 90;
      transition: transform .3s ease;
      transform: translateX(-100%);
    }
    #editorPanel.visible {
      transform: translateX(0);
    }
    @media (prefers-color-scheme: dark) {
      #editorPanel {
        background: rgba(24,24,27,.95);
        border-right-color: rgba(127,127,127,.3);
        box-shadow: 2px 0 12px rgba(0,0,0,.4);
      }
    }

    .editor-header {
      padding: 16px 18px;
      border-bottom: 1px solid rgba(127,127,127,.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .editor-header h2 {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
    }
    #closeEditor {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 24px;
      line-height: 1;
      cursor: pointer;
      padding: 0;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      opacity: .6;
      transition: all .2s ease;
    }
    #closeEditor:hover {
      background: rgba(127,127,127,.12);
      opacity: 1;
    }

    #editorTextarea {
      flex: 1;
      margin: 0;
      border: none;
      border-radius: 0;
      padding: 16px 18px;
      resize: none;
      font-size: 13px;
      line-height: 1.6;
    }

    .CodeMirror-wrap {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .CodeMirror {
      height: 100% !important;
      flex: 1 !important;
      font-size: 13px !important;
      line-height: 1.6 !important;
      background: transparent !important;
      color: inherit !important;
    }
    .CodeMirror-gutters {
      background: transparent !important;
      border-right: 1px solid rgba(127,127,127,.1) !important;
    }
    .CodeMirror-linenumber {
      color: rgba(127,127,127,.5) !important;
    }
    @media (prefers-color-scheme: dark) {
      .CodeMirror .cm-header { color: #82aaff !important; font-weight: 600 !important; }
      .CodeMirror .cm-strong { color: #c3e88d !important; font-weight: bold !important; }
      .CodeMirror .cm-em { color: #c3e88d !important; font-style: italic !important; }
      .CodeMirror .cm-link { color: #89ddff !important; }
      .CodeMirror .cm-url { color: #89ddff !important; }
      .CodeMirror .cm-quote { color: #697098 !important; font-style: italic !important; }
      .CodeMirror .cm-comment { color: #697098 !important; }
      .CodeMirror .cm-variable-2 { color: #f78c6c !important; }
      .CodeMirror .cm-variable-3 { color: #c792ea !important; }
    .CodeMirror-cursor { border-left-color: #f8f8f2 !important; }
    .CodeMirror-dialog {
      z-index: 30;
      background: rgba(0,0,0,.35);
    }
    }
    @media (prefers-color-scheme: light) {
      .CodeMirror .cm-header { color: #0066cc !important; font-weight: 600 !important; }
      .CodeMirror .cm-strong { color: #008000 !important; font-weight: bold !important; }
      .CodeMirror .cm-em { color: #008000 !important; font-style: italic !important; }
      .CodeMirror .cm-link { color: #0066cc !important; }
      .CodeMirror .cm-url { color: #0066cc !important; }
      .CodeMirror .cm-quote { color: #666 !important; font-style: italic !important; }
      .CodeMirror .cm-comment { color: #666 !important; }
      .CodeMirror .cm-variable-2 { color: #d73a49 !important; }
      .CodeMirror .cm-variable-3 { color: #6f42c1 !important; }
    .CodeMirror-cursor { border-left-color: #333 !important; }
    .CodeMirror-dialog {
      z-index: 30;
      background: rgba(255,255,255,.9);
    }
    }

    .editor-footer {
      padding: 10px 18px;
      border-top: 1px solid rgba(127,127,127,.15);
      font-size: 11px;
      opacity: .6;
    }

    #resizeHandle {
      position: fixed;
      left: 400px;
      top: 0;
      width: 6px;
      height: 100vh;
      cursor: col-resize;
      z-index: 95;
      transition: all .3s ease;
      transform: translateX(-100%);
      opacity: 0;
    }
    #resizeHandle.visible {
      transform: translateX(0);
      opacity: 1;
    }
    #resizeHandle:hover,
    #resizeHandle.dragging {
      background: rgba(74,158,255,.3);
    }

    #mindmap {
      transition: width .3s ease, margin-left .3s ease;
      touch-action: none;
    }
    body.editor-open #mindmap {
      width: calc(100vw - 400px);
      margin-left: 400px;
    }
  </style>
</head>

<body>
  <button id="toggleEditor" type="button" aria-label="Toggle Editor">Edit</button>

  <div id="editorPanel">
    <div class="editor-header">
      <h2>Markdown Editor</h2>
      <button id="closeEditor" type="button" aria-label="Close Editor">×</button>
    </div>
    <textarea id="editorTextarea" placeholder="# Your Markdown Here
## Add headings, lists, and Mermaid diagrams
```mermaid
flowchart TB
  A[Start] --> B[End]
```"></textarea>
    <div class="editor-footer">
      <span id="charCount">0 characters</span>
    </div>
  </div>

  <div id="resizeHandle"></div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h1>Paste Markdown → Mindmap (+ Mermaid)</h1>
      <p>Markmap pass → Mermaid run inside nodes → bake → Markmap relayout → fit.</p>
      <textarea id="paste" placeholder="# Title
## Node with Mermaid
```mermaid
flowchart TB
  A[&quot;Long label that should wrap and not spill out to the right in the Mermaid node&quot;] --> B[Done]
```"></textarea>
      <div class="row">
        <div class="hint">Copy Markmap-formatted text here.</div>
        <div class="button-group">
          <button id="copyPrompt" type="button">Copy Prompt</button>
          <button id="example" type="button">Example</button>
        </div>
      </div>
    </div>
  </div>

  <svg id="mindmap"></svg>

  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/mode/overlay.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/dialog/dialog.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/search/searchcursor.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/addon/search/search.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/xml/xml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/markdown/markdown.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/gfm/gfm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.18.12"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-view@0.18.12/dist/browser/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.18.12/dist/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/turndown@7.2.0/dist/turndown.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js"></script>

  <script>
    (() => {
      const $ = (s) => document.querySelector(s);

      const svgEl = $("#mindmap");
      const overlayEl = $("#overlay");
      const pasteEl = $("#paste");
      const copyPromptBtn = $("#copyPrompt");
      const exampleBtn = $("#example");

      const toggleEditorBtn = $("#toggleEditor");
      const editorPanel = $("#editorPanel");
      const closeEditorBtn = $("#closeEditor");
      const editorTextarea = $("#editorTextarea");
      const resizeHandle = $("#resizeHandle");
      const charCount = $("#charCount");

      let editorVisible = localStorage.getItem("editorVisible") === "true" || false;
      let editorWidth = parseInt(localStorage.getItem("editorWidth") || "400");
      let isResizing = false;
      let codeMirror = null;
      let codeMirrorInitialized = false;
      let pendingEditorFocus = false;

      const mmapi = window.markmap;
      if (!mmapi?.Transformer || !mmapi?.Markmap) { alert("Markmap failed to load."); return; }
      if (!window.TurndownService) { alert("Turndown failed to load."); return; }
      if (!window.mermaid?.run) { alert("Mermaid failed to load."); return; }

      const { Transformer, Markmap, Toolbar } = mmapi;
      const transformer = new Transformer();

      const escapeHtml = (s) => String(s).replace(/[&<>]/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;" }[c]));
      function sanitizeMermaidLabel(raw, opts = {}) {
        const {
          lineBreak = "<br/>",
          preserveExisting = true,
          normalizeHtmlEntities = true,
          useNamedColon = true,
        } = opts;

        if (raw == null) return "";

        let s = String(raw);
        s = s.replace(/\r\n?/g, "\n");

        if (normalizeHtmlEntities) {
          s = s.replace(/&#(\d+);/g, "#$1;");
          s = s.replace(/&([A-Za-z][A-Za-z0-9]+);/g, "#$1;");
        }

        let reAlnum;
        try {
          reAlnum = new RegExp("^[\\p{L}\\p{N}]$", "u");
        } catch {
          reAlnum = /^[A-Za-z0-9]$/;
        }

        const entityRe = /^#(?:\d{1,7}|[A-Za-z][A-Za-z0-9]{1,31});/;

        const encodeChunk = (chunk) => {
          let out = "";
          for (let i = 0; i < chunk.length; ) {
            if (preserveExisting && chunk[i] === "#") {
              const m = chunk.slice(i).match(entityRe);
              if (m) {
                out += m[0];
                i += m[0].length;
                continue;
              }
            }

            const cp = chunk.codePointAt(i);
            const ch = String.fromCodePoint(cp);
            const step = ch.length;

            if (useNamedColon && ch === ":") {
              out += "#colon;";
            } else if (reAlnum.test(ch)) {
              out += ch;
            } else {
              out += `#${cp};`;
            }

            i += step;
          }
          return out;
        };

        return s.split("\n").map(encodeChunk).join(lineBreak);
      }

      function sanitizeMermaidSourceLabels(mermaidSource, opts = {}) {
        const patterns = [
          { open: '["', close: '"]' },
          { open: '("', close: '")' },
          { open: "{{", close: "}}" },
        ];

        const src = String(mermaidSource ?? "");
        let out = "";
        let i = 0;

        const isEdgeLabelStart = (pos) => {
          for (let j = pos - 1; j >= 0; j--) {
            const ch = src[j];
            if (ch === " " || ch === "\t") continue;
            return ch === "-" || ch === "=" || ch === "." || ch === ">";
          }
          return false;
        };

        while (i < src.length) {
          let p = null;
          for (const cand of patterns) {
            if (src.startsWith(cand.open, i)) { p = cand; break; }
          }

          if (p) {
            const start = i + p.open.length;
            const end = src.indexOf(p.close, start);
            if (end === -1) { out += src.slice(i); break; }
            const inner = src.slice(start, end);
            out += p.open + sanitizeMermaidLabel(inner, opts) + p.close;
            i = end + p.close.length;
            continue;
          }

          if (src[i] === "|" && isEdgeLabelStart(i)) {
            const start = i + 1;
            const end = src.indexOf("|", start);
            if (end === -1) { out += src.slice(i); break; }
            const inner = src.slice(start, end);
            out += "|" + sanitizeMermaidLabel(inner, opts) + "|";
            i = end + 1;
            continue;
          }

          out += src[i++];
        }

        return out;
      }
      const promptMd = [
        "Act as a thought and learning partner. Generate a high-density self-standing Markmap + Mermaid visualization. Think VERY HARD as if your life DEPENDED ON IT!",
        "",
        "",
        "### Formatting Constraints",
        "",
        "1. Container: Wrap entire response in quadruple backticks (````markdown [content] ````) to allow clean copy-pasting.",
        "",
        "2. Visual Elements (Optional/Context-Dependent):",
        "",
        "   - Mermaid diagram and charts",
        "       - Use Mermaid markdown-strings: A[\"long label ...\"] for best wrapping.",
        "       - Use <br/> for newlines inside labels",
        "       - Mermaid Hash-Entity Standard: Mermaid requires characters to be escaped using # instead of & (e.g., #34; instead of &quot;) - Example: `Status: \"Processing #1\" (Update Required)` -> `Status#colon;#32;#34;Processing#32;#35;1#34;#32;#40;Update#32;Required#41;`",
        "       - Put mermaid diagrams inside markdown code blocks starting with ```mermaid",
        "       - In flowcharts: prefer LR over TB and always include a START and END block",
        "",
        "   - Tables: Use for multi-variable comparisons",
        "",
        "   - Math: Use KaTex in markdown. Replace the \\sqrt{x} command with a fractional exponent (x)^{1/2}. Using sqrt is forbidden due to markmap bug.",
        "",
        "   - HTML (e.g., images) as it is supported by Markmap https://markmap.js.org/docs/markmap",
        "",
        "   - Code blocks with formatting",
        "",
        "   - Hyperlink references to other docs, video timestamps, etc.",
        "",
        "   - Embedded images with appropriate width and height control",
        "",
        "   - Use emojis and special chars for visual aid",
        "",
        "   - Include ascii art when other token efficient forms are incapable",
        "",
        "   - Embed the visual elements throughout the markdown where appropriate. Avoid skewing all visuals into a single node",
        "",
        "",
        "### Content & Style",
        "",
        "1. Tone: Concise. Sacrifice grammar for density.",
        "",
        "2. Structure: Use hierarchical headings (##, ###) to define the mindmap nodes. Don't mix headings and lists in the same hierarchy.",
        "",
        "3. Note that Markmap IGNORES paragraph text (i.e., not list, heading, mermaid, table or code block, etc)"
      ].join("\n");
      const md = transformer.md;
      const defaultFence =
        md.renderer.rules.fence ||
        ((tokens, idx, options, env, self) => self.renderToken(tokens, idx, options));

      md.renderer.rules.fence = (tokens, idx, options, env, self) => {
        const t = tokens[idx];
        const lang = (t.info || "").trim().split(/\s+/)[0].toLowerCase();
        if (lang === "mermaid") {
          const cleaned = sanitizeMermaidSourceLabels(t.content || "", {
            lineBreak: "<br/>",
            preserveExisting: true,
            normalizeHtmlEntities: true,
            useNamedColon: true,
          });
          return `<pre class="mermaid">${escapeHtml(cleaned)}</pre>`;
        }
        return defaultFence(tokens, idx, options, env, self);
      };

      const mm = Markmap.create(svgEl);

      const toolbar = new Toolbar();
      toolbar.attach(mm);

      const shouldBlockWheel = (target) =>
        (target === svgEl || svgEl.contains(target)) &&
        !editorPanel.contains(target) &&
        !overlayEl.contains(target);

      svgEl.addEventListener("wheel", (e) => {
        if (shouldBlockWheel(e.target)) e.preventDefault();
      }, { passive: false });
      const toolbarEl = toolbar.render();
      toolbarEl.style.position = "absolute";
      toolbarEl.style.right = "16px";
      toolbarEl.style.bottom = "16px";
      document.body.appendChild(toolbarEl);

      function setEditorWidth(width) {
        const minWidth = 250;
        const maxWidth = window.innerWidth - 200;
        editorWidth = Math.max(minWidth, Math.min(maxWidth, width));

        editorPanel.style.width = editorWidth + "px";
        resizeHandle.style.left = editorWidth + "px";

        if (editorVisible) {
          svgEl.style.width = `calc(100vw - ${editorWidth}px)`;
          svgEl.style.marginLeft = editorWidth + "px";
        }

        localStorage.setItem("editorWidth", editorWidth);
      }

      function focusEditor() {
        if (codeMirror) {
          codeMirror.refresh();
          codeMirror.focus();
        } else {
          editorTextarea.focus();
        }
      }

      function scheduleEditorFocus() {
        if (!editorVisible) return;
        setTimeout(() => focusEditor(), 360);
      }

      function toggleEditor(show) {
        editorVisible = show !== undefined ? show : !editorVisible;

        if (editorVisible) {
          editorPanel.classList.add("visible");
          resizeHandle.classList.add("visible");
          document.body.classList.add("editor-open");
          setEditorWidth(editorWidth);
          pendingEditorFocus = true;

          toggleEditorBtn.style.left = `${editorWidth + 16}px`;

          if (!codeMirrorInitialized) {
            initCodeMirror();
            if (pasteEl.value) {
              setEditorValue(pasteEl.value);
            }
          } else {
            if (pasteEl.value && !getEditorValue()) {
              setEditorValue(pasteEl.value);
            }
          }

          if (codeMirrorInitialized) {
            pendingEditorFocus = false;
            scheduleEditorFocus();
          }
        } else {
          editorPanel.classList.remove("visible");
          resizeHandle.classList.remove("visible");
          document.body.classList.remove("editor-open");
          svgEl.style.width = "100vw";
          svgEl.style.marginLeft = "0";

          toggleEditorBtn.style.left = "16px";
        }

        localStorage.setItem("editorVisible", editorVisible);

        setTimeout(() => mm.fit(), 320);
      }

      function updateCharCount() {
        const count = codeMirror ? codeMirror.getValue().length : editorTextarea.value.length;
        charCount.textContent = `${count} character${count !== 1 ? 's' : ''}`;
      }

      function getEditorValue() {
        return codeMirror ? codeMirror.getValue() : editorTextarea.value;
      }

      function setEditorValue(value) {
        if (codeMirror) {
          codeMirror.setValue(value || '');
        } else {
          editorTextarea.value = value || '';
        }
        updateCharCount();
      }

      let editorTimeout = null;
      const handleEditorInput = () => {
        updateCharCount();
        clearTimeout(editorTimeout);
        editorTimeout = setTimeout(() => {
          const value = getEditorValue();
          render(value);
          pasteEl.value = value;
        }, 50);
      };

      function initCodeMirror() {
        if (codeMirrorInitialized || !window.CodeMirror) return;

        try {
          codeMirror = CodeMirror.fromTextArea(editorTextarea, {
            mode: 'gfm',
            lineNumbers: true,
            lineWrapping: true,
            theme: 'default',
            placeholder: editorTextarea.placeholder,
            autofocus: false,
            tabSize: 2,
            indentUnit: 2,
            extraKeys: {
              "Ctrl-E": () => toggleEditor(),
              "Cmd-E": () => toggleEditor(),
              "Ctrl-F": "find",
              "Cmd-F": "find",
              "Ctrl-G": "findNext",
              "Cmd-G": "findNext",
              "Shift-Ctrl-G": "findPrev",
              "Shift-Cmd-G": "findPrev",
              "Esc": () => { if (editorVisible) toggleEditor(false); }
            }
          });

          if (codeMirror) {
            codeMirror.on("change", handleEditorInput);

            codeMirror.on("paste", async (instance, event) => {
              event.preventDefault();
              const mdText = await getPasteMarkdown(event.clipboardData);
              if (mdText) instance.replaceSelection(mdText, "around");
            });

            codeMirrorInitialized = true;
            if (editorVisible && pendingEditorFocus) {
              pendingEditorFocus = false;
              scheduleEditorFocus();
            }
          }
        } catch (e) {
          console.warn("CodeMirror initialization failed, using plain textarea:", e);
          codeMirror = null;
          codeMirrorInitialized = false;
          if (editorVisible && pendingEditorFocus) {
            pendingEditorFocus = false;
            setTimeout(() => editorTextarea.focus(), 0);
          }
        }
      }

      function fallbackCopyText(text) {
        const temp = document.createElement("textarea");
        temp.value = text;
        temp.setAttribute("readonly", "");
        temp.style.position = "absolute";
        temp.style.left = "-9999px";
        document.body.appendChild(temp);
        temp.select();
        try { document.execCommand("copy"); } catch {}
        document.body.removeChild(temp);
      }

      async function copyPromptToClipboard() {
        try {
          await navigator.clipboard.writeText(promptMd);
          return true;
        } catch {
          fallbackCopyText(promptMd);
          return false;
        }
      }

      copyPromptBtn.addEventListener("click", async () => {
        const original = copyPromptBtn.textContent;
        const ok = await copyPromptToClipboard();
        copyPromptBtn.textContent = ok ? "Copied" : "Copied (fallback)";
        setTimeout(() => { copyPromptBtn.textContent = original; }, 1200);
      });

      toggleEditorBtn.addEventListener("click", () => toggleEditor());
      closeEditorBtn.addEventListener("click", () => toggleEditor(false));

      resizeHandle.addEventListener("mousedown", (e) => {
        isResizing = true;
        resizeHandle.classList.add("dragging");
        document.body.style.cursor = "col-resize";
        document.body.style.userSelect = "none";
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (!isResizing) return;
        setEditorWidth(e.clientX);
        mm.fit();
      });

      document.addEventListener("mouseup", () => {
        if (isResizing) {
          isResizing = false;
          resizeHandle.classList.remove("dragging");
          document.body.style.cursor = "";
          document.body.style.userSelect = "";
        }
      });

      editorTextarea.addEventListener("input", () => {
        if (!codeMirrorInitialized) {
          handleEditorInput();
        }
      });

      document.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "f") {
          if (editorVisible && codeMirrorInitialized && codeMirror) {
            e.preventDefault();
            codeMirror.focus();
            codeMirror.execCommand("find");
            return;
          }
        }
        if ((e.ctrlKey || e.metaKey) && e.key === "e") {
          e.preventDefault();
          toggleEditor();
        }
        if (e.key === "Escape" && editorVisible) {
          toggleEditor(false);
        }
      });

      setEditorWidth(editorWidth);

      const turndownService = new window.TurndownService({
        headingStyle: "atx",
        codeBlockStyle: "fenced",
        bulletListMarker: "-"
      });

      function markmapNormalize(mdText) {
        let s = (mdText || "").replace(/\r\n/g, "\n");
        const trimmed = s.trim();
        const fenced = trimmed.match(/^```(?:markdown|md)\s*\n([\s\S]*?)\n```$/);
        if (fenced) s = fenced[1];
        s = s
          .replace(/^(.+)\n=+\s*$/gm, (_, t) => `# ${t.trim()}`)
          .replace(/^(.+)\n-+\s*$/gm, (_, t) => `## ${t.trim()}`);


        const fixedLines = s.split("\n");
        const result = [];
        let lastHeadingLevel = 3;
        let needsSeparatorForList = false;

        for (let i = 0; i < fixedLines.length; i++) {
          const line = fixedLines[i];
          const nextLine = fixedLines[i + 1] || '';

          const headingMatch = line.match(/^(#{1,6})\s+/);
          if (headingMatch) {
            lastHeadingLevel = headingMatch[1].length;

            let hasListAfter = false;
            let hasMermaidAfter = false;

            for (let j = i + 1; j < fixedLines.length; j++) {
              const checkLine = fixedLines[j].trim();
              if (checkLine === '') continue;

              if (checkLine.match(/^[-*+]\s+/)) {
                hasListAfter = true;
              } else if (checkLine === '```mermaid' && hasListAfter) {
                hasMermaidAfter = true;
                break;
              } else if (checkLine.match(/^#{1,6}\s+/)) {
                break;
              }
            }

            result.push(line);

            if (hasListAfter && hasMermaidAfter) {
              needsSeparatorForList = true;
              result.push('');
              const separatorLevel = Math.min(lastHeadingLevel + 1, 6);
              result.push('#'.repeat(separatorLevel) + ' Details');
              result.push('');
            } else if (hasListAfter) {
              if (nextLine.match(/^[-*+]\s+/)) {
                result.push('');
              }
            }
            continue;
          }

          const listMatch = line.match(/^(\s*)[-*+]\s+/);
          if (listMatch && needsSeparatorForList) {
            result.push(line);
            continue;
          }

          if (line.trim() === '```mermaid' && needsSeparatorForList) {
            const separatorLevel = Math.min(lastHeadingLevel + 1, 6);
            result.push('');
            result.push('#'.repeat(separatorLevel) + ' Diagram');
            result.push('');
            needsSeparatorForList = false;
          }

          result.push(line);
        }

        s = result.join("\n");
        return s.replace(/\n{3,}/g, "\n\n").trim() + "\n";
      }

      let renderedOnce = false;
      let pending = 0;
      let lastEditorSearch = "";

      const nextFrame = () => new Promise((r) => requestAnimationFrame(r));
      const nextFrames = async (n) => { for (let i = 0; i < n; i++) await nextFrame(); };

      function hideOverlayOnce() {
        if (!renderedOnce) {
          overlayEl.classList.add("hidden");
          renderedOnce = true;

          if (pasteEl.value) {
            setEditorValue(pasteEl.value);
          }
        }
      }

      const IS_SAFARI = (() => {
        const ua = navigator.userAgent;
        const vendor = navigator.vendor || "";
        return /Safari/.test(ua) && /Apple Computer/.test(vendor) &&
          !/Chrome|Chromium|CriOS|FxiOS|EdgiOS/.test(ua);
      })();
      let mermaidInitialized = false;
      function ensureMermaidInit() {
        if (mermaidInitialized) return;
        window.mermaid.initialize({
          startOnLoad: false,
          wrap: true,
          wrapPadding: 8,
          markdownAutoWrap: true,
          // Safari/WebKit foreignObject positioning bugs can hide labels.
          htmlLabels: !IS_SAFARI,
          flowchart: { htmlLabels: !IS_SAFARI },
          sequence: { htmlLabels: !IS_SAFARI },
          gantt: { htmlLabels: !IS_SAFARI },
        });
        mermaidInitialized = true;
      }

      function fixMermaidSvgClipping(scopeEl) {
        const svgs = scopeEl.querySelectorAll('foreignObject .mermaid-rendered svg, foreignObject svg[id^="mermaid-"]');
        for (const svg of svgs) {
          svg.style.overflow = "visible";
          try {
            const bbox = svg.getBBox();
            const pad = 8;
            const vb = svg.getAttribute("viewBox");
            if (!vb) {
              svg.setAttribute("viewBox", `${bbox.x-pad} ${bbox.y-pad} ${bbox.width+2*pad} ${bbox.height+2*pad}`);
            } else {
              const parts = vb.split(/\s+/).map(Number);
              if (parts.length === 4 && parts.every(Number.isFinite)) {
                const [x,y,w,h] = parts;
                svg.setAttribute("viewBox", `${x-pad} ${y-pad} ${w+2*pad} ${h+2*pad}`);
              }
            }
            const wantW = Math.ceil(bbox.width + 2*pad);
            const wantH = Math.ceil(bbox.height + 2*pad);
            const wAttr = parseFloat(svg.getAttribute("width") || "");
            const hAttr = parseFloat(svg.getAttribute("height") || "");
            if (Number.isFinite(wAttr) && wAttr < wantW) svg.setAttribute("width", String(wantW));
            if (Number.isFinite(hAttr) && hAttr < wantH) svg.setAttribute("height", String(wantH));
          } catch {}
        }
      }

      async function renderMermaidInsideMarkmap(currentToken) {
        ensureMermaidInit();

        const rendered = svgEl.querySelectorAll("[data-mermaid-rendered]");
        for (const el of rendered) {
          if (el.querySelector("svg") && el.dataset.mermaidSource) {
            el.textContent = el.dataset.mermaidSource;
          }
          el.removeAttribute("data-processed");
          delete el.dataset.mermaidRendered;
          el.classList.remove("mermaid-rendered");
          if (!el.classList.contains("mermaid")) el.classList.add("mermaid");
        }

        const nodes = Array.from(svgEl.querySelectorAll("foreignObject pre.mermaid, foreignObject div.mermaid"));

        if (!nodes.length) return false;

        try { if (document.fonts?.ready) await document.fonts.ready; } catch {}
        if (currentToken !== pending) return false;

        if (window.mermaid?.mermaidAPI?.reset) {
          try { window.mermaid.mermaidAPI.reset(); } catch {}
        }

        for (const el of nodes) {
          if (el.querySelector("svg") && el.dataset.mermaidSource) {
            el.textContent = el.dataset.mermaidSource;
          }
          el.dataset.mermaidSource = el.textContent || "";
          el.removeAttribute("data-processed");
        }

        await window.mermaid.run({ nodes, suppressErrors: true });

        for (const el of nodes) {
          el.dataset.mermaidRendered = "1";
          el.classList.remove("mermaid");
          el.classList.add("mermaid-rendered");
        }

        await nextFrames(1);
        fixMermaidSvgClipping(svgEl);

        return true;
      }

      function bakeForeignObjectHTMLIntoData(node) {
        const found = mm.findElement(node);
        if (found?.g) {
          const fo = found.g.querySelector("foreignObject");
          const container = fo?.firstElementChild;
          if (container) node.content = container.innerHTML;
        }
        if (node.children) for (const c of node.children) bakeForeignObjectHTMLIntoData(c);
      }

      async function render(mdText) {
        const text = (mdText || "").trim();
        if (!text) return;

        const token = ++pending;
        try {
          const normalized = markmapNormalize(text);
          const { root } = transformer.transform(normalized);

          await mm.setData(root);

          await nextFrames(2);
          if (token !== pending) return;

          mm.fit();
          await nextFrames(1);
          if (token !== pending) return;

          const hadMermaid = await renderMermaidInsideMarkmap(token);
          if (token !== pending) return;

          if (hadMermaid) {
            await nextFrames(2);
            if (token !== pending) return;

            bakeForeignObjectHTMLIntoData(mm.state.data);
            await mm.renderData(mm.state.data);

            await nextFrames(2);
            if (token !== pending) return;

            mm.fit();
          }

          hideOverlayOnce();
        } catch (e) {
          console.error("Render failed:", e);
          alert("Render error: " + (e?.message || String(e)));
        }
      }

      function looksLikeMarkdown(s) {
        const t = (s || "").trim();
        if (!t) return false;
        return (
          /(^|\n)\s{0,3}#{1,6}\s+\S/.test(t) ||
          /(^|\n)\s{0,3}[-*+]\s+\S/.test(t) ||
          /(^|\n)\s{0,3}\d+\.\s+\S/.test(t)
        );
      }

      function clipboardToMarkmapMdFromDataTransfer(dt) {
        const html = dt?.getData("text/html") || "";
        const plain = dt?.getData("text/plain") || "";

        if (looksLikeMarkdown(plain)) return markmapNormalize(plain);

        if (html && html.trim()) {
          try {
            const converted = turndownService.turndown(html);
            const normalized = markmapNormalize(converted);
            if (normalized.trim()) return normalized;
          } catch (e) {
            console.warn("Turndown failed; fallback to plain", e);
          }
        }
        return markmapNormalize(plain);
      }

      async function getPasteMarkdown(dataTransfer, fallbackOnly = false) {
        if (!fallbackOnly && dataTransfer) {
          const mdText = clipboardToMarkmapMdFromDataTransfer(dataTransfer);
          if (mdText.trim()) return mdText;
        }
        return markmapNormalize(await getPasteTextFallback());
      }

      async function getPasteTextFallback() {
        try { return (await navigator.clipboard.readText()) || ""; }
        catch { return ""; }
      }

      function applyPasteText(mdText, replaceAll = true) {
        if (!mdText.trim()) return;

        if (replaceAll) {
          pasteEl.value = mdText;
        } else {
          const start = pasteEl.selectionStart ?? pasteEl.value.length;
          const end = pasteEl.selectionEnd ?? start;
          try { pasteEl.setRangeText(mdText, start, end, "end"); }
          catch { pasteEl.value += mdText; }
        }
        queueMicrotask(() => render(pasteEl.value));
      }

      pasteEl.addEventListener("paste", async (ev) => {
        ev.preventDefault();
        const mdText = await getPasteMarkdown(ev.clipboardData);
        applyPasteText(mdText, true);
        pasteEl.focus();
      });

      pasteEl.addEventListener("beforeinput", async (ev) => {
        if (ev.inputType !== "insertFromPaste") return;
        ev.preventDefault();
        const mdText = await getPasteMarkdown(null, true);
        applyPasteText(mdText, true);
        pasteEl.focus();
      });

      document.addEventListener("paste", async (ev) => {
        if (ev.target === pasteEl) return;
        if (editorPanel.contains(ev.target)) return;
        ev.preventDefault();
        const mdText = await getPasteMarkdown(ev.clipboardData);
        applyPasteText(mdText, true);
        pasteEl.focus();
      }, true);

      let t = null;
      pasteEl.addEventListener("input", () => {
        clearTimeout(t);
        t = setTimeout(() => render(pasteEl.value), 50);
      });

      exampleBtn.addEventListener("click", () => {
        const mdText = [
          "# Markmap + Mermaid (Wrap + No Spill Test)",
          "## A Mermaid node with long text",
          "```mermaid",
          "flowchart TB",
          "  A[\"This is a very long label containing a URL-like token https://example.com/some/really/really/really/long/path and also regular prose so we can verify wrapping and token breaking inside the node.\"] --> B[\"Another long label that should wrap rather than spilling out to the right side of the shape.\"]",
          "  B --> C[\"Done\"]",
          "  A -->|Status: \"Processing #1\" (Update Required)| C",
          "```",
          "## Notes",
          "- Wrapping: mermaid config wrap + CSS max-width for labels",
          "- No clipping: SVG overflow visible + padded viewBox via getBBox()",
        ].join("\n");
        pasteEl.value = mdText;
        render(mdText);
      });

      window.addEventListener("resize", () => mm.fit());
      window.addEventListener("load", () => pasteEl.focus());
    })();
  </script>
</body>
</html>
